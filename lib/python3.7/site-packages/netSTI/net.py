import numpy as np
import timeit
import netSTI.mydata as data
import netSTI.copula as copula
import netSTI.netgen as ngen

class MyError(Exception): 
	def __init__(self, arg): 
		self.arg = arg

###################################################################
# common functions

def get_params(unit = 26): 
	return data.Params(unit).pInf, \
	data.Params(unit).pCondom, \
	data.Params(unit).redCondom, \
	data.Params(unit).meanActs, \
	data.Params(unit).pRec, \
	data.Params(unit).max_contact, \
	data.Params(unit).max_ept, \
	data.Params(unit).alpha, \
	data.Params(unit).cMedicine, \
	data.Params(unit).cInvestigate, \
	data.Params(unit).cTest, \
	data.Params(unit).q, \
	data.Params(unit).discount_rate 


def get_instantaneous_sex_net_of_infected(rel_hist, I, T, t): 
	""" Extract information of the instantaneous sexual network

	Argument:
	---------
	rel_hist (numpy array): relationship history
	I (numpy array): a vector of infected status
	T (numpy array): a vector of treated status
	t (integer): time step

	Return: 
	-------
	tmp_rel (numpy array): temporary sex relationship of the infected at time t
	"""
	# 1. get current relationships at time t
	tmp_rel = rel_hist[(rel_hist[:, 2] <= t) & (rel_hist[:, 3] >= t)]
	# 2. keep relationships that only have one infected ID
	dum = (I[tmp_rel[:, 0]] + I[tmp_rel[:, 1]]) == 1
	tmp_rel = tmp_rel[dum]
	# 3. keep relationships that no one is on treatment
	dum = (T[tmp_rel[:, 0]] + T[tmp_rel[:, 1]]) == 0
	tmp_rel = tmp_rel[dum]
	return tmp_rel

def gen_inf_id_from_external(count_all, Npop, pEFoI, ID_cluster, graph, \
	time_horizon, inf_independent = True): 
	if graph != 'community': 
		if inf_independent == True: 
			tmp_p = Npop * (count_all/np.sum(count_all)) * pEFoI
		else: 
			tmp_p = Npop * (1 / Npop) * np.ones(Npop) * pEFoI
		tmp_p = np.tile(tmp_p, (time_horizon, 1))
		dum = np.random.binomial(1, p = tmp_p)
	else: 
		if inf_independent == True: 
			tmp_count_all = (ID_cluster == 1) * count_all 
			tmp_p = Npop * (tmp_count_all/np.sum(tmp_count_all)) * pEFoI
		else: 
			tmp_p = Npop * (1 / np.sum((ID_cluster == 1))) * (ID_cluster == 1) * pEFoI
		tmp_p = np.tile(tmp_p, (time_horizon, 1))
		dum = np.random.binomial(1, p = tmp_p)
	seed_ix = np.vstack(np.where(dum == 1)).T
	return seed_ix

def make_screening_schedule(rel_hist, time_horizon, Npop, unit_per_year, pScr): 
	tmp_sch = np.zeros((time_horizon, Npop))
	for t in range(time_horizon): 
		tmp_part = np.zeros(Npop)
		# get network of last year, and calculate the number of sex partners in the past 12 months
		tmp_rel = rel_hist[np.where((rel_hist[:, 3] >= (t - unit_per_year + 1)) & (rel_hist[:, 2] <= t))]
		tmp_ix, tmp_n = np.unique(tmp_rel[:, :2], return_counts = True)
		tmp_part[tmp_ix] = tmp_n
		# get a dummy variable indicating whether people were screened in the past year. 
		if (t - unit_per_year) < 0: 
			tmp_begin = 0
		not_yet_scr = (np.sum(tmp_sch[tmp_begin:t], axis = 0) == 0)
		tmp_part = tmp_part * not_yet_scr
		tmp_p = pScr * tmp_part / np.sum(tmp_part) * Npop
		tmp_sch[t] = np.random.binomial(1, p = tmp_p)
	
	# get the screening schedule at each time step
	# column 0 is the time step
	# column 1 is the id that was screened at the time step
	out_sch = np.vstack(np.where(tmp_sch == 1)).T
	return out_sch

def create_tracker_and_outcome_vectors(Npop, time_horizon): 
	# set up output vectors
	S0 = np.ones(Npop)
	I0 = np.zeros(Npop)
	T0 = np.zeros(Npop) # this state is only for recording time of treatment
	person_time0 = np.zeros(Npop)
	n_notification0 = np.zeros(Npop)
	n_name_trace0 = np.zeros(Npop)
	n_infection0 = np.zeros(Npop) # only count new infection in the analysis time (last 10 years)
	n_intervention0 = np.zeros(Npop) # only count new infection in the analysis time (last 10 years)

	out_S0 = np.zeros(time_horizon) # prevalence of S
	out_I0 = np.zeros(time_horizon) # prevalence of I
	out_newI0 = np.zeros(time_horizon)
	out_nDeliver0 = np.zeros(time_horizon)
	out_nContactTrace0 = np.zeros(time_horizon)
	out_nNotified0 = np.zeros(time_horizon)
	out_nTrueTreat0 = np.zeros(time_horizon)
	out_nOvertreat0 = np.zeros(time_horizon)
	out_nTest0 = np.zeros(time_horizon)
	out_nScreen0 = np.zeros(time_horizon)
	out_nTrueTreatIntervention0 = np.zeros(time_horizon)
	out_pEfficient0 = np.zeros(time_horizon)
	out_CostMedicine0 = np.zeros(time_horizon)
	out_CostTracing0 = np.zeros(time_horizon)
	out_CostTest0 = np.zeros(time_horizon)

	return S0, I0, T0, person_time0, n_notification0, n_name_trace0, n_infection0, n_intervention0, \
		out_S0, out_I0, out_newI0, out_nDeliver0, out_nContactTrace0, out_nNotified0, out_nTrueTreat0, \
		out_nOvertreat0, out_nTest0, out_nScreen0, out_nTrueTreatIntervention0, out_pEfficient0, \
		out_CostMedicine0, out_CostTracing0, out_CostTest0


def trans_dynamics(I, tmp_rel, acts, pInf, pCondom, redCondom): 
	infID = np.where(I == 1)[0]
	dum = np.random.binomial(1, \
		p = (1 - (1 - pInf * (pCondom * (1 - redCondom) + (1 - pCondom))) ** acts), 
		size = tmp_rel.shape[0])
	new_infID = np.unique(tmp_rel[dum == 1, :2])
	new_infID = np.setdiff1d(new_infID, infID)
	return infID, new_infID


def notify_contact_deliver_sex_part(tmp_screen_I, rel_hist, unit_per_year, pContact, alpha, t): 
	dum1 = 1 * np.in1d(rel_hist[:, 0], tmp_screen_I)
	dum2 = 1 * np.in1d(rel_hist[:, 1], tmp_screen_I)
	dum = ((dum1 + dum2) == 1)
	screen_rel = rel_hist[dum]
	# get right time period for testing 
	dum = (screen_rel[:, 2] <= t) & ((t - screen_rel[:, 3]) <= (unit_per_year / 2))
	screen_rel = screen_rel[dum]
	tmp = np.round((t - screen_rel[:, 3]) * ((t - screen_rel[:, 3]) >= 0) / 2)
	dum = np.random.binomial(1, p = pContact * (np.exp(-alpha * tmp)), size = screen_rel.shape[0])
	tmp_name, tmp_count = np.unique(screen_rel[dum == 1, :2], return_counts = True)
	dum = ~np.in1d(tmp_name, tmp_screen_I)
	tmp_name = tmp_name[dum]
	tmp_count = tmp_count[dum]
	return tmp_name, tmp_count


def contact_trace_name(n_name_trace, max_contact, tmp_screen_I, p_treat_tr, infID): 
	tmp_name = np.where(n_name_trace > 0)[0]
	if tmp_name.shape[0] > max_contact: 
		tmp_count = n_name_trace[tmp_name]
		tmp_sort = np.argsort(-tmp_count)
		tmp_name = tmp_name[tmp_sort]
		tmp_name = tmp_name[:(max_contact + 1)]
	num_contact = tmp_name.shape[0]
	dum = (np.random.binomial(1, p = p_treat_tr, size = num_contact) == 1)
	trace_test_name = tmp_name[dum]
	# if a partner get tested due to contact tracing, replace the n_name_trace with 0
	n_name_trace[trace_test_name] = 0 
	num_test = trace_test_name.shape[0]
	treat_name = trace_test_name[np.in1d(trace_test_name, infID)]
	tmp_screen_I = np.concatenate((tmp_screen_I, treat_name))
	return tmp_screen_I, tmp_name, n_name_trace, num_contact, num_test, treat_name


def implement_strategy(ID, rel_hist, Npop, time_horizon, unit_per_year, seed_ix, \
	scr_schedule, count_all, strategy = 'null', \
	pContact_PN = 0.49, pContact_ept = 0.7, pContact_tr = 0.7, \
	p_treat_PN = 0.71, p_treat_ept = 0.79, p_treat_tr = 0.79): 

	pInf, pCondom, redCondom, acts, pRec, max_contact, max_ept, alpha, \
	cMedicine, cInvestigate, cTest, q, discount_rate = get_params(unit_per_year)

	S, I, T, person_time, n_notification, n_name_trace, n_infection, n_intervention, \
	out_S, out_I, out_newI, out_nDeliver, out_nContactTrace, out_nNotified, out_nTrueTreat, \
	out_nOvertreat, out_nTest, out_nScreen, out_nTrueTreatIntervention, out_pEfficient, \
	out_CostMedicine, out_CostTracing, out_CostTest = create_tracker_and_outcome_vectors(Npop, time_horizon)

	for t in range(0, time_horizon): 
	# for t in range(0, 26): 
		## transmission dynamics
		tmp_rel = get_instantaneous_sex_net_of_infected(rel_hist, I, T, t)
		infID, new_infID = trans_dynamics(I, tmp_rel, acts, pInf, pCondom, redCondom)
		tmp_seed = seed_ix[seed_ix[:, 0] == t, 1]
		tmp_seed = np.setdiff1d(tmp_seed, infID)

		## Recovered from treated
		treatID = np.where(T == 1)[0]
		T[treatID] = 0
		S[treatID] = 1
		tmp_seed = np.setdiff1d(tmp_seed, treatID)
		new_infID = np.concatenate((new_infID, tmp_seed))

		## screening and testing
		scr_ID = scr_schedule[scr_schedule[:, 0] == t, 1]
		tmp_screen_I = scr_ID[np.in1d(scr_ID, infID)]
		I[tmp_screen_I] = 0
		T[tmp_screen_I] = 1
		S_ID = np.where(S == 1)[0]
		tmp_screen_S = scr_ID[np.in1d(scr_ID, S_ID)]
		out_nScreen[t] = tmp_screen_I.shape[0] + tmp_screen_S.shape[0]	
		out_nTest[t] = tmp_screen_I.shape[0] + tmp_screen_S.shape[0]
		out_nTrueTreat[t] = tmp_screen_I.shape[0]

		# infected ID who get treated
		if strategy == "tracing": 
			tmp_screen_I, contact_name, n_name_trace, num_contact, num_test, treat_name = \
				contact_trace_name(n_name_trace, max_contact, tmp_screen_I, p_treat_tr, infID)
			out_nTrueTreatIntervention[t] = treat_name.shape[0]
			out_nTest[t] += num_test
			n_intervention[contact_name] += 1
			tmp_name, tmp_count = notify_contact_deliver_sex_part(tmp_screen_I, \
				rel_hist, unit_per_year, pContact_tr, alpha, t)
			n_name_trace[tmp_name] += tmp_count
			out_nContactTrace[t] = num_contact
			out_nTrueTreat[t] = tmp_screen_I.shape[0]
			out_pEfficient[t] = out_nTrueTreatIntervention[t] / out_nContactTrace[t - 1]
			I[tmp_screen_I] = 0
			T[tmp_screen_I] = 1

		if strategy == "EPT": 			
			tmp_name, tmp_count = notify_contact_deliver_sex_part(tmp_screen_I, rel_hist, \
				unit_per_year, pContact_ept, alpha, t)
			out_nDeliver[t] = np.sum(tmp_count)
			n_intervention[tmp_name] += 1
			dum = (np.random.binomial(1, p = 1 - (1 - p_treat_ept) ** tmp_count) == 1)
			tmp_name = tmp_name[dum]
			tmp_ept_treat = tmp_name[np.in1d(tmp_name, infID)]
			out_nTrueTreat[t] = tmp_screen_I.shape[0] + tmp_ept_treat.shape[0]
			out_nOvertreat[t] = tmp_name.shape[0] - tmp_ept_treat.shape[0]
			out_nTrueTreatIntervention[t] = tmp_ept_treat.shape[0]
			out_pEfficient[t] = out_nTrueTreatIntervention[t] / out_nDeliver[t]
			tmp_screen_I = np.concatenate((tmp_screen_I, tmp_ept_treat))
			I[tmp_screen_I] = 0
			T[tmp_screen_I] = 1

		if strategy == "PN": 
			if t >= 1: 
				dum = (np.random.binomial(1, p = 1 - (1 - p_treat_PN) ** (n_notification[notify_name])) == 1)
				notify_test_name = notify_name[dum]
				out_nTest[t] += notify_test_name.shape[0]
				notify_true_treat_name = notify_test_name[np.in1d(notify_test_name, infID)]
				out_nTrueTreatIntervention[t] = notify_true_treat_name.shape[0]
				out_pEfficient[t] = out_nTrueTreatIntervention[t] / out_nNotified[t - 1]
				tmp_screen_I = np.concatenate((tmp_screen_I, notify_true_treat_name))
				n_notification[n_notification > 0] = 0

			notify_name, tmp_count = notify_contact_deliver_sex_part(tmp_screen_I, rel_hist, \
				unit_per_year, pContact_PN, alpha, t)
			n_notification[notify_name] += tmp_count
			n_intervention[notify_name] += 1

			out_nNotified[t] = notify_name.shape[0]
			out_nTrueTreat[t] = tmp_screen_I.shape[0]

			I[tmp_screen_I] = 0
			T[tmp_screen_I] = 1
	
		n_infection[new_infID] += 1

		## spontaneous recovered ID
		dum = np.random.binomial(1, p = pRec, size = infID.shape[0]) == 1
		new_recID = infID[dum]
		S[new_recID] = 1
		I[new_recID] = 0

		## updated the health state of the newly infected ID
		S[new_infID] = 0
		I[new_infID] = 1

		person_time += I

		out_S[t] = np.mean(S)
		out_I[t] = np.mean(I)
		out_newI[t] = new_infID.shape[0]

		d_factor = (1 / (1 + discount_rate)) ** (t + 1)
		out_CostMedicine[t] = (out_nTrueTreat[t] + out_nOvertreat[t]) * (cMedicine * d_factor)
		out_CostTracing[t] = out_nContactTrace[t] * (cInvestigate * d_factor)
		out_CostTest[t] = out_nTest[t] * (cTest * d_factor)
	
	n_yrs = time_horizon / unit_per_year
	sum_all = {}
	sum_all["S"] = np.nanmean(out_S)
	sum_all["I"] = np.nanmean(out_I)
	sum_all["newI"] = np.nansum(out_newI)
	sum_all["nDeliver"] = np.nansum(out_nDeliver)
	sum_all["nContactTrace"] = np.nansum(out_nContactTrace)
	sum_all["nNotified"] = np.nansum(out_nNotified)
	sum_all["nTrueTreat"] = np.nansum(out_nTrueTreat)
	sum_all["nOvertreat"] = np.nansum(out_nOvertreat)
	sum_all["nTest"] = np.nansum(out_nTest)
	sum_all["nScreen"] = np.nansum(out_nScreen)
	sum_all["nTrueTreatIntervention"] = np.nansum(out_nTrueTreatIntervention)
	sum_all["pEfficient"] = np.nanmean(out_pEfficient)
	sum_all["pEverInfected"] = np.sum(n_infection > 0) / Npop
	sum_all["averageTimesInfected"] = np.mean(n_infection[n_infection > 0] / n_yrs)
	sum_all["nIntervention"] = np.nansum(n_intervention)
	sum_all["pEverBeenIntervention"] = np.sum(n_intervention > 0) / Npop
	sum_all["avgTimesBeenIntervene"] = np.mean(n_intervention[n_intervention > 0] / n_yrs)
	sum_all["average_person_time"] = np.mean(person_time / n_yrs)
	sum_all["corr_timesInf_and_degree"] = np.round(np.corrcoef(count_all, n_infection)[0, 1], 4)
	sum_all["corr_PT_and_degree"] = np.round(np.corrcoef(count_all, person_time)[0, 1], 4)
	sum_all["CostMedicine"] = np.nansum(out_CostMedicine)
	sum_all["CostTracing"] = np.nansum(out_CostTracing)
	sum_all["CostTest"] = np.nansum(out_CostTest)
	sum_all["TotalCost"] = sum_all["CostMedicine"] + sum_all["CostTracing"] + sum_all["CostTest"]
	return sum_all, out_I


def SIR_net_generator(run, Npop, years = 20, days = 14, 
	graph = "random", pEFoI = (1 / 5000) / 2, 
	pContact_PN = 0.49, pContact_ept = 0.7, pContact_tr = 0.7, 
	p_treat_PN = 0.71, p_treat_ept = 0.79, p_treat_tr = 0.79, 
	independent = True, calibration = False, 
	analysis_window = 10, output_netsum = False, output_net = False): 

	'''
	Npop = 5000
	years = 5
	days = 14 # 14 days; bi-weekly time step
	run = np.random.choice(list(range(1, 1001)), 1)
	graph = "power_law"
	strategy = "PN" 
	pEFoI =  (1 / 5000) / 2
	independent = False
	calibration = True
	analysis_window = 2

	pContact_PN = 0.49
	pContact_ept = 0.7
	pContact_tr = 0.7
	p_treat_PN = 0.71
	p_treat_ept = 0.79
	p_treat_tr = 0.79

	# 4 strategies: do nothing, EPT, contact tracing_degree (contact high degree nodes first), contact tracing_chronology (first come, first serve.)
	'''

	degree = data.SexBehavior().degree
	degree_dist = data.SexBehavior().degree_dist
	mean_degree = np.sum(degree * degree_dist)
	Ndegree = mean_degree * years
	unit_per_year = int(365 / days)
	time_horizon = unit_per_year * years
	n_cluster = data.Params(unit_per_year).n_cluster
	pScr = data.Params(unit_per_year).pScr

	if calibration == False: 
		np.random.seed(run)

	ID = np.arange(Npop)
	ID_cluster = (np.floor(ID / (Npop/n_cluster)) + 1).astype(int)

	rel_hist = ngen.graph_generator(graph, ID, Npop, Ndegree, time_horizon, years, \
		ID_cluster = ID_cluster, pCluster = 0.99, independent = independent)
	
	t_begin = (time_horizon - unit_per_year * analysis_window)

	if output_netsum == True: 
		net_out = ngen.SumNet(rel_hist, Npop).sumarize_net_result(time_horizon, t_begin)
		return net_out

	if output_net == True: 
		return rel_hist

	# only keep network in the analysis window and shift the time 
	rel_hist[:, 2] = rel_hist[:, 2] - t_begin
	rel_hist[:, 3] = rel_hist[:, 3] - t_begin
	# update time horizon
	time_horizon  = time_horizon - t_begin
	out_avg_degree = out_avg_degree[t_begin:]

	tmp_name, tmp_count = np.unique(rel_hist[np.where(rel_hist[:, 3] >= 0), :2], return_counts = True) 
	count_all = np.zeros(Npop)
	count_all[tmp_name] = tmp_count


	seed_ix = gen_inf_id_from_external(count_all, Npop, pEFoI, ID_cluster, graph, \
		time_horizon, inf_independent = True)

	scr_schedule = make_screening_schedule(rel_hist, time_horizon, Npop, unit_per_year, pScr)

	null_sum_all, null_I = implement_strategy(ID, rel_hist, Npop, time_horizon, unit_per_year, seed_ix, \
		scr_schedule, count_all, strategy = 'null', \
		pContact_PN = pContact_PN, pContact_ept = pContact_ept, pContact_tr = pContact_tr, \
		p_treat_PN = p_treat_PN, p_treat_ept = p_treat_ept, p_treat_tr = p_treat_tr)
	pn_sum_all, pn_I = implement_strategy(ID, rel_hist, Npop, time_horizon, unit_per_year, seed_ix, \
		scr_schedule, count_all, strategy = 'PN', \
		pContact_PN = pContact_PN, pContact_ept = pContact_ept, pContact_tr = pContact_tr, \
		p_treat_PN = p_treat_PN, p_treat_ept = p_treat_ept, p_treat_tr = p_treat_tr)
	ept_sum_all, ept_I = implement_strategy(ID, rel_hist, Npop, time_horizon, unit_per_year, seed_ix, \
		scr_schedule, count_all, strategy = 'EPT', \
		pContact_PN = pContact_PN, pContact_ept = pContact_ept, pContact_tr = pContact_tr, \
		p_treat_PN = p_treat_PN, p_treat_ept = p_treat_ept, p_treat_tr = p_treat_tr)
	tr_sum_all, tr_I = implement_strategy(ID, rel_hist, Npop, time_horizon, unit_per_year, seed_ix, \
		scr_schedule, count_all, strategy = 'tracing', \
		pContact_PN = pContact_PN, pContact_ept = pContact_ept, pContact_tr = pContact_tr, \
		p_treat_PN = p_treat_PN, p_treat_ept = p_treat_ept, p_treat_tr = p_treat_tr)

	return {"run": run, "null": null_sum_all, "pn": pn_sum_all, \
		"ept": ept_sum_all, "tracing": tr_sum_all} 



'''
import timeit

aa = timeit.default_timer()
run = np.random.choice(np.arange(10000), 1)
kk = SIR_net_generator(run, 5000, years = 5, days = 14, 
	graph = "power_law", pEFoI = 50 * (1 / 5000) / 2 , 
	pContact_PN = 0.49, pContact_ept = 0.7, pContact_tr = 0.7, 
	p_treat_PN = 0.71, p_treat_ept = 0.79, p_treat_tr = 0.79, 
	independent = False, calibration = False, 
	analysis_window = 2, output_net = False)
print(timeit.default_timer() - aa)
'''

