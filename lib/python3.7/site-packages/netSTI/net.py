import numpy as np
import networkx as nx 
import pandas as pd 
import copy
import timeit
import operator
import scipy.stats as stats
import netSTI.mydata as data

class MyError(Exception): 
	def __init__(self, arg): 
		self.arg = arg

###################################################################
# common functions

def get_params(unit = 26): 
	return data.Params(unit).init_prev, \
	data.Params(unit).pInf, \
	data.Params(unit).pCondom, \
	data.Params(unit).redCondom, \
	data.Params(unit).pScr, \
	data.Params(unit).pRec, \
	data.Params(unit).pContact_PN, \
	data.Params(unit).pContact_ept, \
	data.Params(unit).pContact_tr, \
	data.Params(unit).p_treat_PN, \
	data.Params(unit).p_treat_ept, \
	data.Params(unit).max_contact, \
	data.Params(unit).max_ept, \
	data.Params(unit).alpha, \
	data.Params(unit).cMedicine, \
	data.Params(unit).cInvestigate, \
	data.Params(unit).cTest, \
	data.Params(unit).n_cluster, \
	data.Params(unit).q, \
	data.Params(unit).discount_rate 


def period_Relation(N, dur, dur_dist, time_horizon): 
	''' Assign beginning and end times to each relationship
	
	Arguments: 
	N (integer): # of relaltionships
	dur (numpy vector): a vector of mean duration 
	dur_dist (numpy vector): a vector of distribution of duration. This is a proportion
	time_horizon (integer): number of cycles

	Returns: 
	rel_begin: a vector of beginning time of a relationship
	rel_end: a vector of end time of a relationship
	'''
	rel_begin = np.random.choice(list(range(0, time_horizon)), N)
	duration = np.random.choice(dur, N, p = dur_dist) 
	rel_end = rel_begin + duration
	return rel_begin, rel_end


def generate_edge_list_array(sampMatrix, Npop, dur, dur_dist, time_horizon): 
	""" Creating the relationship between individuals using edge list format
	
	Arguments: 
	sampMatrix (numpy array): an array of probability of tie formation in each cell. 
	Npop (integer): Population size. 

	Returns: 
	out_rel (numpy array): an edge list shaped as numpy array with 4 columns. Each row represents 
	a relationship. Column 0 is the ID of partner 1. Column 1 is the ID of partner 2. Column 2
	is the beginning cycle of the relationship. Column 3 is the end cycle of the relationship. 	
	"""
	out_rel = [None] * Npop

	for i in range(sampMatrix.shape[0]): 
		part_ID = np.where((sampMatrix[i] == 1))[0]
		part_ID = part_ID[part_ID > i]
		agent_ID = np.repeat(i, part_ID.shape[0])
		rel_beg, rel_end = period_Relation(part_ID.shape[0], dur = dur, dur_dist = dur_dist, time_horizon = time_horizon)
		out_rel[i] = np.vstack((agent_ID, part_ID, rel_beg, rel_end)).T

	out_rel = np.vstack(out_rel)
	if out_rel.shape[0] != np.sum(sampMatrix) / 2: 
		MyError("row number of the edgelist is different than the sum of adjacency matrix divided by 2")
	return out_rel


def random_graph_generator(ID, Npop, Ndegree, dur, dur_dist, time_horizon): 
	"""Generate cumulative random networks
	
	Arguments: 
	ID: a numpy vector of individual IDs.
	Npop (integer): population size 
	Ndegree: an integer indicates the average number of cumulative sex partners that an individual has
	within the time_horizon.
	dur (numpy vector): a vector of mean duration 
	dur_dist (numpy vector): a vector of distribution of duration. This is a proportion
	time_horizon (integer): number of cycles

	Returns: 
	out_rel (numpy array): an edge list shaped as numpy array with 4 columns. Each row represents 
	a relationship. Column 0 is the ID of partner 1. Column 1 is the ID of partner 2. Column 2
	is the beginning cycle of the relationship. Column 3 is the end cycle of the relationship. 
	"""

	p_tie = ((Ndegree * Ndegree)/(Ndegree * (Npop - 1))) / 2
	tmpMatrix = np.random.binomial(1, size = (Npop, Npop), p = p_tie)
	tmpMatrix = tmpMatrix + tmpMatrix.T
	tmpMatrix[tmpMatrix > 1] = 1
	np.fill_diagonal(tmpMatrix, 0)

	# generate edge list
	out_rel = generate_edge_list_array(tmpMatrix, Npop = Npop, dur = dur, dur_dist = dur_dist, \
		time_horizon = time_horizon)
	return out_rel


def community_graph_generator(ID, Npop, Ndegree, ID_cluster, dur, dur_dist, time_horizon, pCluster = 0.99): 
	"""Generate cumulative community structured networks
	
	Arguments: 
	ID: a numpy vector of individual IDs.
	Npop (integer): population size
	Ndegree: an integer indicates the average number of cumulative sex partners that an individual has
	within the time_horizon.
	ID_cluster (numpy array): a vector of cluster ID for each ID. 
	dur (numpy vector): a vector of mean duration 
	dur_dist (numpy vector): a vector of distribution of duration. This is a proportion
	time_horizon (integer): number of cycles
	pCluster (float): the probabilty of assortative matching within the same community 

	Returns: 
	out_rel (numpy array): an edge list shaped as numpy array with 4 columns. Each row represents 
	a relationship. Column 0 is the ID of partner 1. Column 1 is the ID of partner 2. Column 2
	is the beginning cycle of the relationship. Column 3 is the end cycle of the relationship. 
	"""
	# calculate the probability of tie formation with individuals in and outside of the community
	p_in_cl = ((Ndegree * pCluster) / (Npop / np.unique(ID_cluster).shape[0] - 1)) / 2
	p_out_cl = ((Ndegree * (1 - pCluster)) / (Npop - (Npop / np.unique(ID_cluster).shape[0]))) / 2

	# making a probability matrix 
	tmpMatrix = np.tile(ID_cluster[:, None], Npop)
	tmpMatrix = (tmpMatrix == tmpMatrix.T)
	tmpMatrix = tmpMatrix * p_in_cl + (1 - tmpMatrix) * p_out_cl
	np.fill_diagonal(tmpMatrix, 0)

	# sample the whether two individuals are sex partners or not
	tmpMatrix = np.random.binomial(1, p = tmpMatrix)
	tmpMatrix = tmpMatrix + tmpMatrix.T
	tmpMatrix[tmpMatrix > 1] = 1
	np.fill_diagonal(tmpMatrix, 0)

	# generate edge list
	out_rel = generate_edge_list_array(tmpMatrix, Npop = Npop, dur = dur, dur_dist = dur_dist, \
		time_horizon = time_horizon)
	return out_rel


def power_law_graph_generator(ID, Npop, Ndegree, dur, dur_dist, time_horizon): 
	"""Generate cumulative power law networks
	
	Arguments: 
	ID: a numpy vector of individual IDs.
	Npop (integer): population size
	Ndegree: an integer indicates the average number of cumulative sex partners that an individual has
	within the time_horizon.
	dur (numpy vector): a vector of mean duration 
	dur_dist (numpy vector): a vector of distribution of duration. This is a proportion
	time_horizon (integer): number of cycles

	Returns: 
	out_rel (numpy array): an edge list shaped as numpy array with 4 columns. Each row represents 
	a relationship. Column 0 is the ID of partner 1. Column 1 is the ID of partner 2. Column 2
	is the beginning cycle of the relationship. Column 3 is the end cycle of the relationship. 
	"""

	nPart = data.PowerLawDD().nPart
	plDist = data.PowerLawDD().plDist
	gen_dd = -np.sort(-np.random.choice(nPart, size = Npop, p = plDist))
	counter = np.zeros(Npop)
	tmpMatrix = np.zeros((Npop, Npop))
	for i in ID: 
		n_samp = int(gen_dd[i] - counter[i])
		if n_samp > 0: 
			include_set = np.where(gen_dd - counter > 0)[0]		
			include_set = np.setdiff1d(include_set, i)
			has_rel_set = np.where(tmpMatrix[i] == 1)[0]
			include_set = np.setdiff1d(include_set, has_rel_set)
			tmp_p = gen_dd[include_set] / np.sum(gen_dd[include_set])
			if include_set.shape[0] > n_samp: 
				sampID = np.random.choice(include_set, p = tmp_p, size = n_samp, replace = False)
			else: 
				sampID = include_set
			tmpMatrix[i, sampID] = 1
			tmpMatrix[sampID, i] = 1
			counter[i] += sampID.shape[0]
			counter[sampID] += 1

	# generate edge list
	out_rel = generate_edge_list_array(tmpMatrix, Npop = Npop, dur = dur, dur_dist = dur_dist, \
		time_horizon = time_horizon)
	return out_rel


def inf_sample(key, inf_contact, pInf): 
	temp = inf_contact[key]
	temp2 = np.random.binomial(1, pInf, len(inf_contact[key])).tolist()
	out = {key: [temp[x] for x in range(len(temp)) if temp2[x] == 1]}
	return out


# graph summary
def annual_G_summary(annual_rel_dict, g): 
	# the input has to be networkx object
	G = nx.Graph(annual_rel_dict[g])
	Npop = len(G.node)
	node_degree = dict(G.degree())
	degrees = [val for key, val in node_degree.items()]
	avg_degree = np.mean(degrees)
	var_degree = np.var(degrees)
	degree_dist = {i: degrees.count(i)/Npop for i in set(degrees)}
	prop_isolates = len([x for x in degrees if x == 0])/Npop
	Gc = max(nx.connected_component_subgraphs(G), key=len)
	prop_in_Gc = len(Gc.node())/Npop
	avg_path = nx.average_shortest_path_length(G)

	return {"prop_isolates": prop_isolates, "avg_degree": avg_degree, "var_degree": var_degree, 
		"prop_in_Gc":prop_in_Gc, "avg_path":avg_path, "degree_dist": degree_dist}


def monthly_degree_dist(rel_hist, Npop, t): 
	G = nx.Graph(rel_hist[t])
	node_degree = dict(G.degree())
	degrees = [val for key, val in node_degree.items()]
	temp_dist = {i: degrees.count(i)/Npop for i in set(degrees)}
	temp_key = [key for key, val in temp_dist.items()]
	out = {i: temp_dist[i] if i in temp_key else 0 for i in range(0, 21)}
	out[0] = 1-sum([val for key, val in temp_dist.items()])
	out[20] = sum([val for key, val in temp_dist.items() if key >= 20])
	return out


def pert(n, x_min, x_max, x_mode, lam = 4): 
	x_range = x_max-x_min
	if x_range == 0: 
		np.repeat(x_min, n)
	mu = ( x_min + x_max + lam * x_mode ) / ( lam + 2 )
	if mu == x_mode: 
		v = (lam/2) + 1
	else: 
		v = ((mu-x_min)*(2*x_mode-x_min-x_max))/(( x_mode - mu ) * ( x_max - x_min ))
	w = (v*(x_max - mu))/(mu-x_min)
	return stats.beta.rvs(v, w, size = n)*x_range + x_min

####################################################################

def SIR_net_generator(run, Npop, meanActs = 27, Ndegree = 4, years = 20, days = 14, 
	strategy = "contact tracing_degree", graph = "random", check_steady_state = False): 
	'''
	Npop = 5000
	years = 10
	days = 14 # 14 days; bi-weekly time step
	run = np.random.choice(list(range(1, 1001)), 1)
	graph_function = random_graph_generator
	strategy = "null" 
	meanActs = 27
	# 4 strategies: do nothing, EPT, contact tracing_degree (contact high degree nodes first), contact tracing_chronology (first come, first serve.)
	'''

	Ndegree = 4 * years
	unit_per_year = int(365 / days)
	time_horizon = unit_per_year * years
	acts = meanActs / unit_per_year

	init_prev, pInf, pCondom, redCondom, pScr, pRec, \
	pContact_PN, pContact_ept, pContact_tr, p_treat_PN, p_treat_ept, \
	max_contact, max_ept, alpha, cMedicine, cInvestigate, cTest, \
	n_cluster, q, discount_rate = get_params(unit_per_year)

	init_inf = int(Npop * init_prev)
	np.random.seed(run)

	rel_hist = dict([(key, []) for key in range(1, time_horizon+1)])
	attr_hist = dict([(key, []) for key in range(0, time_horizon+1)])
	inf_hist = dict([(key, []) for key in range(1, time_horizon+1)])

	ID = np.arange(Npop)
	S = np.ones(Npop)
	I = np.zeros(Npop)
	T = np.zeros(Npop) # this state is only for recording time of treatment

	ID_cluster = (np.floor(ID / (Npop/n_cluster)) + 1).astype(int)
	init_select = np.where(ID_cluster == 1)[0]
	infID = np.sort(np.random.choice(init_select, init_inf, replace = False))
	I[infID] = 1
	S[infID] = 0

	bbb = timeit.default_timer()

	# set up output vectors
	out_S = np.zeros(time_horizon) # prevalence of S
	out_I = np.zeros(time_horizon) # prevalence of I
	out_newI = np.zeros(time_horizon)
	out_newT = np.zeros(time_horizon)
	out_nDeliver = np.zeros(time_horizon)
	out_nOvertreat = np.zeros(time_horizon)
	out_nInfTreatIntervention = np.zeros(time_horizon)
	out_nInvestigate = np.zeros(time_horizon)
	out_nNotified = np.zeros(time_horizon)
	out_nTested = np.zeros(time_horizon)
	out_avg_degree = np.zeros(time_horizon)
	out_CostMedicine = np.zeros(time_horizon)
	out_CostTracing = np.zeros(time_horizon)
	out_CostTest = np.zeros(time_horizon)
	out_Util = np.zeros(time_horizon)

	if graph == "random": 
		rel_hist = random_graph_generator(ID, Npop, Ndegree, dur, dur_dist, time_horizon)
	if graph == "community": 
		rel_hist = community_graph_generator(ID, Npop, Ndegree, ID_cluster, dur, dur_dist, time_horizon)
	if graph == "power_law": 
		rel_hist = power_law_graph_generator(ID, Npop, Ndegree, dur, dur_dist, time_horizon)

	original_name_ls = []
	tracing_ls = []

	testEPT_vec = np.repeat(p_treat_ept, Npop)
	testTR_vec = np.repeat(p_treat_tr, Npop)
	testPN_vec = np.repeat(p_treat_PN, Npop)

	aaa = timeit.default_timer()
	for t in range(0, time_horizon): 
	# for t in range(0, 10): 
		# preparing relation data at one time step
		# print(t)
		# t = 50
		temp_annual_rel = copy.deepcopy(annual_rel_dict[1])
		# aaa =timeit.default_timer()
		actor1, actor2 = zip(*[(k, key) for k, v in temp_annual_rel.items() for key, val in v.items() if (val["begin"] <= t) & (val["end"] > t)])
		rel_dict = dict([(key, {}) for key in set(actor1)])
		for x in range(len(actor1)): 
			rel_dict[actor1[x]].update({actor2[x]: temp_annual_rel[actor1[x]][actor2[x]]})
			rel_dict[actor1[x]][actor2[x]]["infection"] = 0

		infID = [key for key, val in attr_df.items() if val['I'] == 1]
		S_ID = [key for key, val in attr_df.items() if val['S'] == 1]
		inf_actor = list(set(actor1+actor2).intersection(set(infID)))
		new_infID = []

		for x in inf_actor: 
			temp = [key for key, val in rel_dict[x].items()]
			temp = list(set(temp).intersection(set(S_ID)))
			freq = np.random.poisson(lam = 27/12, size = len(temp)) # we only sample the frequence of sex for the discordant couples to calculate infection
			inf_or_not = np.random.binomial(1, p = 1-(1-pInf*(pCondom*(1-redCondom)+(1-pCondom)))**freq).tolist() 
			for y in range(len(temp)): 
				rel_dict[x][temp[y]].update({"infection":inf_or_not[y]})
				# infection is directional
			new_infID += [temp[y] for y in range(len(temp)) if inf_or_not[y] == 1]
		new_infID = list(set(new_infID) - set(infID))

		rel_hist[t+1] = rel_dict

		# print(timeit.default_timer() - aaa)
		###################################################
		# if t >= 36:  
		if t >= (time_horizon - 12*2):  
			# infected ID who get treated
			test_ls = [x for x in range(len(ID)) if np.random.binomial(1, p = rScr, size = 1) == 1]
			screen_ls = list(set(test_ls).intersection(set(infID)))
			# print(screen_ls)
			treat_ls = screen_ls
			contact_investigate = []
			contact_notified = []
			overtreat = []
			deliver_ls = []
			InfTreatIntervention = []

			# print("==== before tracing", contact_treat)

			if strategy == "contact tracing_degree": 
				tempID = copy.deepcopy(screen_ls)
				temp_name = {key: {k: t-v['end'] if v['end'] < t else 0} for key, val in temp_annual_rel.items() if key in tempID for k, v in val.items() if (v['end'] >= t-6) & (v['begin'] < t)}
				temp = {key0: [key1 for key1, val1 in val0.items() if np.random.binomial(1, p = pContact_tr*(np.exp(-alpha*val1)), size = 1) == 1] for key0, val0 in temp_name.items()}
				temp = [val for key, val in temp.items() if len(val) > 0]
				temp_contact = list(set([x for y in temp for x in y])) # this is just for collecting names so it includes those who are uninfected 
				# contact tracing at most max_contact individuals in the population
				contact_investigate = tracing_ls[:(max_contact)] # this is for the cost
				original_name_ls = [original_name_ls[x] for x in range(len(original_name_ls)) if original_name_ls[x] not in contact_investigate] # remove those who were investigated from the original_name_ls
				temp_name = list(set(contact_investigate) - set(treat_ls)) # dropped those who are treated at this time step because they are not going to come in anyways
				temp = np.random.binomial(1, p = testTR_vec[[x-1 for x in temp_name]], size = len(temp_name)).tolist() # for those who are not treated yet, they could come in to be tested with p_treat_tr
				contact_treat = [temp_name[x] for x in range(len(temp_name)) if temp[x] == 1] # this is those who come in to be tested
				test_ls += contact_treat
				contact_treat = list(set(contact_treat).intersection(set(infID))) # those who are tested positive through contact tracing
				treat_ls += contact_treat
				# only collect names of the partners of those who are positive 
				temp_name = {key: {k: t-v['end'] if v['end'] < t else 0} for key, val in temp_annual_rel.items() if key in contact_treat for k, v in val.items() if (v['end'] >= t-6) & (v['begin'] < t)}
				temp = {key0: [key1 for key1, val1 in val0.items() if np.random.binomial(1, p = pContact_tr*(np.exp(-alpha*val1)), size = 1) == 1] for key0, val0 in temp_name.items()}
				temp = [val for key, val in temp.items() if len(val) > 0]
				temp_contact += list(set([x for y in temp for x in y])) # this is just for collecting names so it includes those who are uninfected 
				# print(temp_contact)
				original_name_ls += temp_contact
				original_name_ls = [original_name_ls[x] for x in range(len(original_name_ls)) if original_name_ls[x] not in treat_ls]
				temp = {x: original_name_ls.count(x) for x in original_name_ls}
				tracing_ls = sorted(temp, key=temp.get, reverse=True)
				InfTreatIntervention += contact_treat
			elif strategy == "contact tracing_chronology": 
				tempID = copy.deepcopy(screen_ls)
				temp_name = {key: {k: t-v['end'] if v['end'] < t else 0} for key, val in temp_annual_rel.items() if key in tempID for k, v in val.items() if (v['end'] >= t-6) & (v['begin'] < t)}
				temp = {key0: [key1 for key1, val1 in val0.items() if np.random.binomial(1, p = pContact_tr*(np.exp(-alpha*val1)), size = 1) == 1] for key0, val0 in temp_name.items()}
				temp = [val for key, val in temp.items() if len(val) > 0]
				temp_contact = list(set([x for y in temp for x in y])) # this is just for collecting names so it includes those who are uninfected 
				# contact tracing at most max_contact individuals in the population
				contact_investigate = tracing_ls[:(max_contact)] # this is for the cost
				original_name_ls = [original_name_ls[x] for x in range(len(original_name_ls)) if original_name_ls[x] not in contact_investigate]
				temp_name = list(set(contact_investigate) - set(treat_ls)) # dropped those who are treated at this time step because they are not going to come in anyways
				temp = np.random.binomial(1, p = testTR_vec[[x-1 for x in temp_name]], size = len(temp_name)).tolist() # for those who are not treated yet, they could come in to be tested with p_treat_tr
				contact_treat = [temp_name[x] for x in range(len(temp_name)) if temp[x] == 1] # this is those who come in to be tested
				test_ls += contact_treat
				contact_treat = list(set(contact_treat).intersection(set(infID))) # those who are tested positive through contact tracing
				treat_ls += contact_treat
				# only collect names of the partners of those who are positive 
				temp_name = {key: {k: t-v['end'] if v['end'] < t else 0} for key, val in temp_annual_rel.items() if key in contact_treat for k, v in val.items() if (v['end'] >= t-6) & (v['begin'] < t)}
				temp = {key0: [key1 for key1, val1 in val0.items() if np.random.binomial(1, p = pContact_tr*(np.exp(-alpha*val1)), size = 1) == 1] for key0, val0 in temp_name.items()}
				temp = [val for key, val in temp.items() if len(val) > 0]
				temp_contact += list(set([x for y in temp for x in y])) # this is just for collecting names so it includes those who are uninfected 
				temp_contact = list(set(temp_contact))
				temp_contact = [temp_contact[x] for x in range(len(temp_contact)) if temp_contact[x] not in original_name_ls]
				original_name_ls += temp_contact
				original_name_ls = [original_name_ls[x] for x in range(len(original_name_ls)) if original_name_ls[x] not in treat_ls]
				tracing_ls = copy.deepcopy(original_name_ls)
				InfTreatIntervention += contact_treat
			elif strategy == "EPT": 
				tempID = copy.deepcopy(screen_ls)
				temp_name = {key: {k: t-v['end'] if v['end'] < t else 0} for key, val in temp_annual_rel.items() if key in tempID for k, v in val.items() if (v['end'] >= t-6) & (v['begin'] < t)}
				temp = {key0: [key1 for key1, val1 in val0.items() if np.random.binomial(1, p = pContact_ept*(np.exp(-val1)), size = 1) == 1] for key0, val0 in temp_name.items()}
				temp_deliver = {key: val if len(val) <= max_ept else np.random.choice(val, max_ept, replace = False).tolist() for key, val in temp.items()}
				temp_deliver = [val for key, val in temp_deliver.items() if len(val) > 0] # individuals who got the medical packs
				deliver_ls = list(set([x for y in temp_deliver for x in y]))
				temp = np.random.binomial(1, p = testEPT_vec[[x-1 for x in deliver_ls]], size = len(deliver_ls)).tolist()
				temp_take = [deliver_ls[x] for x in range(len(deliver_ls)) if temp[x] == 1]
				temp_take = list(set([temp_take[x] for x in range(len(temp_take)) if temp_take[x] not in treat_ls]))
				deliver_treat = list(set(temp_take).intersection(set(infID)))
				treat_ls += deliver_treat
				overtreat += list(set(temp_take) - set(deliver_treat))
				InfTreatIntervention += deliver_treat
			elif strategy == "PN": 
				tempID = copy.deepcopy(screen_ls)
				while len(tempID) > 0: 
					# print(tempID)
					temp_name = {key: {k: t-v['end'] if v['end'] < t else 0} for key, val in temp_annual_rel.items() if key in tempID for k, v in val.items() if (v['end'] >= t-6) & (v['begin'] < t)}
					temp = {key0: [key1 for key1, val1 in val0.items() if np.random.binomial(1, p = pContact_PN*(np.exp(-alpha*val1)), size = 1) == 1] for key0, val0 in temp_name.items()}
					# print(temp)
					temp_PN = {key: val if len(val) <= 30 else np.random.choice(val, 30, replace = False).tolist() for key, val in temp.items()} # 30 is the maximum number of partners that you can contact
					temp_PN = [val for key, val in temp_PN.items() if len(val) > 0] 
					# print(temp_PN)
					PN_ls = [x for y in temp_PN for x in y] # individuals who are notified
					temp = np.random.binomial(1, p = testPN_vec[[x-1 for x in PN_ls]], size = len(PN_ls)).tolist() # sample those who get tested p_treat_PN
					temp_test = [PN_ls[x] for x in range(len(PN_ls)) if temp[x] == 1] 
					temp_test = list(set([temp_test[x] for x in range(len(temp_test)) if temp_test[x] not in test_ls])) # individuals who are tested
					test_pos = list(set(temp_test).intersection(set(infID)))
					treat_ls += test_pos
					test_ls += temp_test
					tempID = copy.deepcopy(test_pos)
					InfTreatIntervention += test_pos
					contact_notified += PN_ls
				# print(contact_notified)
				# print("==================")
			# print("==== after tracing", contact_treat)

			for key in treat_ls: 
				attr_df[key]['I'] = 0
				attr_df[key]['S'] = 1

			for key in treat_ls + overtreat: 
				attr_df[key]['T'] = 1 # this is just for treatment record 
		else: 
			test_ls = []
			treat_ls = []
			contact_investigate = []
			contact_notified = []
			overtreat = []
			deliver_ls = []
			InfTreatIntervention = []

		###################################################
		treat_ls = list(set(treat_ls))
		contact_investigate = list(set(contact_investigate))
		test_ls = list(set(test_ls))

		# spontaneous recovered ID
		infID = list(set(infID) - set(treat_ls))
		if len(infID) > 0: 
			temp = np.random.binomial(1, p = pRec, size = len(infID)).tolist()
			new_recID = [infID[x] for x in range(len(infID)) if temp[x] == 1]
			if len(new_recID) > 0: 
				for key in new_recID: 
					attr_df[key]['I'] = 0
					attr_df[key]['S'] = 1

		# update new infected in the attr_df
		if len(new_infID) > 0: 
			for key in new_infID: 
				attr_df[key]['S'] = 0
				attr_df[key]['I'] = 1

		# calculating number of partners
		temp = {key: len(val) for key, val in rel_dict.items()}
		for key, val in attr_df.items(): 
			attr_df[key]["Npartner"] = 0
			attr_df[key].update({"time": t+1})
		for key, val in temp.items(): 
			attr_df[key]["Npartner"] = temp[key]

		attr_hist[t+1] = copy.deepcopy(attr_df)
		# print(timeit.default_timer()-aaa)
		###################################################

		out_sum["time"] += [t+1]
		out_sum["S"] += [sum([val["S"] for key, val in attr_df.items()])/Npop]
		out_sum["I"] += [sum([val["I"] for key, val in attr_df.items()])/Npop]
		out_sum["newI"] += [len(new_infID)]
		out_sum["newT"] += [len(treat_ls)]
		out_sum["nInfTreatIntervention"] += [len(InfTreatIntervention)] # number of infected treated due to intervention. 
		out_sum["nInvestigate"] += [len(contact_investigate)] 
		out_sum["nNotified"] += [len(contact_notified)]
		out_sum["nDeliver"] += [len(deliver_ls)]
		out_sum["nOvertreat"] += [len(overtreat)]
		out_sum["nTested"] += [len(test_ls)]
		out_sum['avg_degree'] += [sum([val["Npartner"] for key, val in attr_df.items()])/Npop]

		temp = out_sum['nDeliver'][t+1] - (out_sum["nOvertreat"][t+1] + out_sum["nInfTreatIntervention"][t+1]) if out_sum['nDeliver'][t+1] == 0 else out_sum['nDeliver'][t+1]
		out_sum['CostMedicine'] += [(out_sum['newT'][t+1] + out_sum['nOvertreat'][t+1] + temp)*(cMedicine*(1/(1+discount_rate))**(t+1))]
		out_sum['CostTracing'] += [out_sum['nInvestigate'][t+1]*(cInvestigate*(1/(1+discount_rate))**(t+1))]
		out_sum['CostTest'] += [out_sum['nTested'][t+1]*(cTest*(1/(1+discount_rate))**(t+1))]

		out_sum['Util'] += [(out_sum["S"][t+1]*Npop + q*out_sum["I"][t+1]*Npop)*(1/(1+discount_rate))**(t+1)]

		# print(timeit.default_timer()-aaa)
	# print(timeit.default_timer()-aaa)
	# final trend output 

	sum_all = {}
	# calculate average duration
	dumI = {key2: [val[key2]['I'] for key, val in attr_hist.items() if (key >= (time_horizon - 12*2 + 1)) & (key < (time_horizon + 1))] for key2 in range(1, Npop+1)}
	temp = {key: [dumI[key][i+1] - dumI[key][i] for i in range(len(dumI[key])-1)] for key in range(1, Npop+1)}
	nI = [sum([x == 1 for x in val]) for key, val in temp.items()]
	# find those who had most partners: 
	npart = {key1: len([key2 for key2, val2 in val1.items()]) for key1, val1 in annual_rel_dict[1].items()}
	npart = sorted(npart, key=lambda k: npart[k], reverse = True)
	idx = [npart[i] - 1 for i in range(0, 11)]
	n_inf10 = np.mean([nI[i] for i in idx])
	# for dealing with the censoring issue of the duration of infection 
	for key in range(1, 1001): 
		if (dumI[key][-1] == 1) & (0 in dumI[key]): 
			# print(dumI[key])
			# detecting the index of last 0 in the index and find the index of "1" next to the last 0
			# idx = (len(dumI[key]) - dumI[key][::-1].index(0) - 1 ) + 1
			idx = dumI[key][::-1].index(0) 
			# change values after the last 0 
			dumI[key][-idx:] = [0 for i in range(1, (idx+1))]
	temp = {key: [dumI[key][i+1] - dumI[key][i] for i in range(len(dumI[key])-1)] for key in range(1, Npop+1)}
	nI = [sum([x == 1 for x in val]) for key, val in temp.items()]
	timeI = [sum([x == 1 for x in val]) for key, val in dumI.items()]
	avgI_per_person = [x/y for x, y in zip(timeI, nI) if y > 0]

	if len(avgI_per_person) != 0: 
		sum_all['avg_durI'] = sum(avgI_per_person)/len(avgI_per_person)
	else: 
		sum_all['avg_durI'] = float("inf")
	sum_all['prevalence'] = out_sum["I"][time_horizon]
	sum_all['newI'] = sum(out_sum["newI"][(time_horizon - 12*2 + 1):])
	sum_all['newT'] = sum(out_sum["newT"])
	sum_all["nInfTreatIntervention"] = sum(out_sum["nInfTreatIntervention"])
	sum_all['nInvestigate'] = sum(out_sum["nInvestigate"])
	sum_all['nNotified'] = sum(out_sum["nNotified"])
	sum_all["nDeliver"] = sum(out_sum["nDeliver"])
	sum_all["nOvertreat"] = sum(out_sum["nOvertreat"])
	sum_all['ever_infected_node'] = Npop - len([x for x in nI if x == 0])
	sum_all['avg_degree'] = sum(out_sum['avg_degree'][(time_horizon - 12*2 + 1):])/len(out_sum['avg_degree'][(time_horizon - 12*2 + 1):])
	if (strategy == "contact tracing_degree") or (strategy == "contact tracing_chronology"):
		sum_all['treat_per_intervention'] = sum_all['nInfTreatIntervention']/sum_all['nInvestigate'] if sum_all['nInvestigate'] != 0 else float("inf")
	elif strategy == "EPT":
		sum_all['treat_per_intervention'] = sum_all['nInfTreatIntervention']/sum_all['nDeliver'] if sum_all['nDeliver'] != 0 else float("inf")
	elif strategy == "PN": 
		sum_all['treat_per_intervention'] = sum_all['nInfTreatIntervention']/sum_all['nNotified'] if sum_all['nNotified'] != 0 else float("inf")
	else: 
		sum_all['treat_per_intervention'] = float("inf")
	sum_all['avg_num_inf10'] = n_inf10

	sum_all['CostMedicine'] = sum(out_sum["CostMedicine"])
	sum_all['CostTracing'] = sum(out_sum["CostTracing"])
	sum_all['CostTest'] = sum(out_sum["CostTest"])
	sum_all['TotalCost'] = sum_all['CostMedicine'] + sum_all['CostTracing'] + sum_all['CostTest'] 
	sum_all['Util'] = sum(out_sum["Util"][(time_horizon - 12*2 + 1):])


	# graph summary
	G_sum_annual = annual_G_summary(annual_rel_dict, 1)

	# monthly degree distribution
	temp_dist = [monthly_degree_dist(rel_hist, Npop, x) for x in range((time_horizon - 12*2 + 1), (time_horizon + 1))]
	degree_dist = dict([(key, []) for key in range(0, 21)])
	for x in range(len(temp_dist)): 
		for k in range(0, 21):
			degree_dist[k].append(temp_dist[x][k])


	# rel_hist = {key: val for key, val in rel_hist.items() if key in range(49, 61)}
	output_rel_hist = {key1: {val1: {val2: val3['infection'] for val2, val3 in val2.items() } 
		for val1, val2 in val1.items() } 
		for key1, val1 in rel_hist.items()} # 1 means infection happend from key1 to key2
	# attr_hist = {key: val for key, val in attr_hist.items() if key in range(49, 61)}

	print(timeit.default_timer()-bbb)

	# outcomes for plot
	# outcomes = {"EL": output_rel_hist, "annualEL": annual_rel_dict, "node": attr_hist}
	# outcomes = {"run": run, "summary": sum_all, "monthly_avg_degree": out_sum['avg_degree'][37:], 
	# 	"monthly_degree_dist": degree_dist}
	if check_steady_state == True: 
		outcomes = out_sum["I"]
	else: 
		outcomes = {"run": run, "summary": sum_all, "G_sum_annual": G_sum_annual, "monthly_avg_degree": out_sum['avg_degree'][(time_horizon - 12*2 + 1):], 
			"monthly_degree_dist": degree_dist, 'p_treat_ept': p_treat_ept, 'p_treat_PN': p_treat_PN, 'p_treat_tr': p_treat_tr}
	return outcomes


def simulation_wrapper(run): 
	print("run =", run)
	'''
	graph_function = random_graph_generator
	graph_function = community_graph_generator
	graph_function = power_law_graph_generator
	'''
	return SIR_net_generator(run, graph_function, 
		Npop = 1000, Ndegree = 4*10, time_horizon = 12*10, 
		pInf = 0.17, pCondom = (0.32+.21)/2, redCondom = 0.6, 
		durI = 6, rScr = 0.3/12, pContact_tr = 0.7, pContact_ept = 0.7, 
		pContact_PN = 0.49, p_treat_tr = 0.79, p_treat_ept = 0.79, p_treat_PN = 0.71, 
		init_prev = 0.05, n_cluster = 5, strategy = "null", max_contact = 30, 
		max_ept = 500, alpha = 1, check_steady_state = True)





'''
import matplotlib as mpl
print(mpl.rcParams['backend'])
mpl.use('TkAgg')
import matplotlib.pyplot as plt
plt.get_backend()
import os
os.chdir("/Users/szu-yukao/Documents/Network_structure_and_STI/networkSTI")
cwd = os.getcwd()
print(cwd)

fig = plt.figure(figsize=(6,4))
xax = np.array([x for x in range(len(out_sum['I']))])
plt.plot(xax, out_sum['I'], color = 'red', linewidth=2)
plt.tight_layout()
plt.savefig('results/trend/test random 5 years.eps', format='eps', dpi=1000)
'''




