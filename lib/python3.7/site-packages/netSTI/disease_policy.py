import numpy as np
import timeit
import netSTI.mydata as data
import netSTI.copula as copula
import netSTI.netgen as ngen

class MyError(Exception): 
	def __init__(self, arg): 
		self.arg = arg

def get_params(unit = 26): 
	return data.Params(unit).pInf, \
	data.Params(unit).pCondom, \
	data.Params(unit).redCondom, \
	data.Params(unit).meanActs, \
	data.Params(unit).pRec, \
	data.Params(unit).max_contact, \
	data.Params(unit).max_ept, \
	data.Params(unit).cMedicine, \
	data.Params(unit).cInvestigate, \
	data.Params(unit).cTest, \
	data.Params(unit).q, \
	data.Params(unit).discount_rate 


def gen_inf_id_from_external(count_all, Npop, pEFoI, ID_cluster, graph, \
	time_horizon, inf_independent = False): 
	'''
	Generate infected individuals who were infected due to external source

	Argument:
	---------
	count_all (numpy array): 1D numpy array. Degree over the evaluation window.
	Npop (integer): population size.
	pEFoI (float): probability of external force of infection.
	ID_cluster (numpy array): 1D numpy array. cluster ID of individual. 
	graph (string): type of graph, which can only be 'random', 'community', 'power_law', or 'empirical'. 
	time_horizon (integer): number of cycles
	inf_independent (boolean): whether the seed infected IDs are independent of their degree. 

	Return: 
	-------
	seed_ix (numpy array): 2D numpy array with 2 columns. Column 0 is the time step the infection is seeded. 
		Column 1 is the infected IDs. 
	'''
	if graph != 'community': 
		if inf_independent == False: 
			tmp_p = Npop * (count_all/np.sum(count_all)) * pEFoI
		else: 
			tmp_p = Npop * (1 / Npop) * np.ones(Npop) * pEFoI
		tmp_p = np.tile(tmp_p, (time_horizon, 1))
		dum = np.random.binomial(1, p = tmp_p)
	else: 
		if inf_independent == False: 
			tmp_count_all = (ID_cluster == 1) * count_all 
			tmp_p = Npop * (tmp_count_all/np.sum(tmp_count_all)) * pEFoI
		else: 
			tmp_p = Npop * (1 / np.sum((ID_cluster == 1))) * (ID_cluster == 1) * pEFoI
		tmp_p = np.tile(tmp_p, (time_horizon, 1))
		dum = np.random.binomial(1, p = tmp_p)
	seed_ix = np.vstack(np.where(dum == 1)).T
	return seed_ix

def make_screening_schedule(rel_hist, time_horizon, Npop, unit_per_year, pScr, PrEPuser = True): 
	'''
	Predetermine screening schedule for individuals
	
	Argument: 
	---------
	rel_hist (numpy array): edge list with relationship beginning and end time. 
	time_horizon (integer): time horizon 
	Npop (integer): population size
	unit_per_year (integer): number of time steps per year. 
	pScr (float): probability of screening at each time step. 
	
	Return: 
	-------
	out_sch (numpy array): a 2D numpy array with 2 columns. Column 0 is the time step that a screening occurs. 
		Column 1 is the individual ID who get screening at the corresponding time step. 

	Note: 
	-----
	Only individuals who had sex partners in the last 12 months would be screened. Also, the likelihood of 
	individual being screened is positively correlated with the number of sex partners in the past year. 
	'''
	tmp_sch = np.zeros((time_horizon, Npop))

	for ct in range(1, 3): 
		tmp_part = np.zeros(Npop)
		tmp_rel = rel_hist[np.where((rel_hist[:, 3] > (unit_per_year * (ct - 1))) & \
			(rel_hist[:, 3] <= (unit_per_year * ct)))]
		tmp_ix, tmp_n = np.unique(tmp_rel[:, :2], return_counts = True)
		tmp_part[tmp_ix] = tmp_n
		tmp_p = tmp_part / np.sum(tmp_part)
		exp_prep = int(Npop * 0.243) # expected number of individuals who are on PrEP. 0.242 was calcaulted using WHPP. 
		tmp_prep = np.random.choice(np.arange(Npop), exp_prep, p = tmp_p, replace = False)
		ix_not_prep = np.setdiff1d(np.arange(Npop), tmp_prep)
		exp_not_prep = int(Npop * pScr) - tmp_prep.shape[0]
		tmp_p = tmp_part[ix_not_prep] / np.sum(tmp_part[ix_not_prep])
		tmp_scr_not_prep = np.random.choice(ix_not_prep, exp_not_prep, p = tmp_p, replace = False)

		if PrEPuser == True: 
			# Assuming PrEP users are screened 2-4 times a year
			freq_scr_prep = np.random.choice([2, 3, 4], tmp_prep.shape[0], replace = True) 
			freq_scr_prep = -np.sort(-freq_scr_prep)
			# sort prep users based on their number of partners
			sort_ix = np.argsort(-tmp_part[tmp_prep])
			tmp_prep = tmp_prep[sort_ix]

			# Assuming individuals who are not on PrEP are only screened once a year
			freq_scr_not_prep = np.repeat(1, tmp_scr_not_prep.shape[0]) 
		else: 
			freq_scr_prep = np.repeat(1, tmp_prep.shape[0]) 
			freq_scr_not_prep = np.repeat(1, tmp_scr_not_prep.shape[0]) 

		tmp_scr = np.concatenate((tmp_prep, tmp_scr_not_prep))
		tmp_freq = np.concatenate((freq_scr_prep, freq_scr_not_prep))
		for i in range(tmp_scr.shape[0]): 
			tmp_ix = tmp_scr[i]
			tmp_n = tmp_freq[i]
			tmp_min = unit_per_year * (ct - 1) + 1
			tmp_max = unit_per_year * ct + 1
			time_ix = np.arange(tmp_min, tmp_max, unit_per_year / tmp_n).astype(np.int)
			tmp_sch[time_ix, tmp_ix] = 1

	out_sch = np.vstack(np.where(tmp_sch == 1)).T
	return out_sch


def get_instantaneous_sex_net_of_infected(el, I, T, t): 
	""" Extract information of the instantaneous sexual network

	Argument:
	---------
	el (numpy array): relationship history
	I (numpy array): a vector of infected status
	T (numpy array): a vector of treated status
	t (integer): time step

	Return: 
	-------
	tmp_rel (numpy array): temporary sex relationship of the infected at time t
	"""
	# 1. get current relationships at time t
	tmp_rel = el[(el[:, 2] <= t) & (el[:, 3] >= t)]
	# 2. keep relationships that only have one infected ID
	dum = (I[tmp_rel[:, 0]] + I[tmp_rel[:, 1]]) == 1
	tmp_rel = tmp_rel[dum]
	# 3. keep relationships that no one is on treatment
	dum = (T[tmp_rel[:, 0]] + T[tmp_rel[:, 1]]) == 0
	tmp_rel = tmp_rel[dum]
	return tmp_rel


def create_tracker_and_outcome_vectors(Npop, time_horizon): 
	# set up output vectors
	S0 = np.ones(Npop)
	I0 = np.zeros(Npop)
	T0 = np.zeros(Npop) # this state is only for recording time of treatment
	last_test0 = np.zeros(Npop)
	person_time0 = np.zeros(Npop)
	n_notification0 = np.zeros(Npop)
	n_name_trace0 = np.zeros(Npop)
	n_infection0 = np.zeros(Npop) # only count new infection in the analysis time (last 10 years)
	n_intervention0 = np.zeros(Npop) # only count new infection in the analysis time (last 10 years)

	out_S0 = np.zeros(time_horizon) # prevalence of S
	out_I0 = np.zeros(time_horizon) # prevalence of I
	out_T0 = np.zeros(time_horizon) # prevalence of T
	out_newI0 = np.zeros(time_horizon)
	out_ext_seed0 = np.zeros(time_horizon)
	out_n_part6mon0 = np.zeros(time_horizon)
	out_n_infPart6mon0 = np.zeros(time_horizon)
	out_nDeliver0 = np.zeros(time_horizon)
	out_nContactTrace0 = np.zeros(time_horizon)
	out_nNotified0 = np.zeros(time_horizon)
	out_nPartnerTestedBefore0 = np.zeros(time_horizon)
	out_nTrueTreat0 = np.zeros(time_horizon)
	out_nOvertreat0 = np.zeros(time_horizon)
	out_nTest0 = np.zeros(time_horizon)
	out_nScreen0 = np.zeros(time_horizon)
	out_nTrueTreatIntervention0 = np.zeros(time_horizon)
	out_pEfficient0 = np.zeros(time_horizon)
	out_CostMedicine0 = np.zeros(time_horizon)
	out_CostTracing0 = np.zeros(time_horizon)
	out_CostTest0 = np.zeros(time_horizon)

	return S0, I0, T0, last_test0, person_time0, n_notification0, n_name_trace0, n_infection0, n_intervention0, \
		out_S0, out_I0, out_T0, out_newI0, out_ext_seed0, out_n_part6mon0, out_n_infPart6mon0, out_nDeliver0, \
		out_nContactTrace0, out_nNotified0, out_nPartnerTestedBefore0, out_nTrueTreat0, \
		out_nOvertreat0, out_nTest0, out_nScreen0, \
		out_nTrueTreatIntervention0, out_pEfficient0, out_CostMedicine0, out_CostTracing0, out_CostTest0


def trans_dynamics(I, tmp_rel, acts, pInf, pCondom, redCondom): 
	'''
	The infected infect the uninfected

	Arguments:
	----------
	I (numpy array): an 1D array indicating whether an individual is infected or not
	tmp_rel (numpy array): an edge list only includes the relationships of the infected. 
	acts (float): average number of sex acts per time step
	pInf (float): probability of transmitting STI per sex act. 
	pCondom (float): probaiblity of using condom per sex act. 
	redCondom (float): risk reduction due to condom use. 

	Return:
	-------
	infID (numpy array): an 1D array of infected individual IDs. 
	new_infID (numpy array): an 1D array of newly infected individual IDs. 

	Notes:
	------
	infID does not include new_infID, vice versa.  
	'''
	infID = np.where(I == 1)[0]
	dum = np.random.binomial(1, \
		p = (1 - (1 - pInf * (pCondom * (1 - redCondom) + (1 - pCondom))) ** acts), 
		size = tmp_rel.shape[0])
	new_infID = np.unique(tmp_rel[dum == 1, :2])
	new_infID = np.setdiff1d(new_infID, infID)
	return infID, new_infID


def notify_contact_deliver_sex_part(el, tmp_screen_I, pContact, unit_per_year, infID, t, alpha = 1.0): 
	'''
	The process that notify, contact, or deliver medicine to the sex partners

	Arguments:
	---------
	el (numpy array): an edge list of each relationship with relationship start and end time. This is a 2D array 
		with 4 columns.
	tmp_screen_I (numpy array): an 1D array with the individuals who are screened at the time step.  
	pContact (float): probability that the index case notifies partners, provides partners' names, 
		or deliver medicine to the partners. 
	alpha (float): Adjusting the likelihood of the ex partners being notified, named or received treatment. 
	unit_per_year (integer): how many units of time in a year. 
	t (integer): the time step. 	

	Return: 
	-------
	tmp_name: the list of individual ids being notified, named or recieved medicine
	tmp_count: the number of times individual ids being notified, named or recieved medicine
	'''	
	dum1 = np.in1d(el[:, 0], tmp_screen_I)
	dum2 = np.in1d(el[:, 1], tmp_screen_I)
	dum = (dum1 | dum2) & (~(dum1 & dum2))
	screen_rel = el[dum]
	# get right time period for testing 
	dum = (screen_rel[:, 2] <= t) & ((t - screen_rel[:, 3]) <= (unit_per_year / 2))
	screen_rel = screen_rel[dum]
	part6mon = np.unique(screen_rel[:, :2]) 
	n_infPart = part6mon[np.in1d(part6mon, infID)].shape[0] - part6mon[np.in1d(part6mon, tmp_screen_I)].shape[0]
	n_part6mon = part6mon.shape[0] - part6mon[np.in1d(part6mon, tmp_screen_I)].shape[0]
	tmp = np.round((t - screen_rel[:, 3]) / 2)
	tmp_p = pContact * np.exp(-alpha * tmp * (tmp >= 0) )
	dum = np.random.binomial(1, p = tmp_p, size = screen_rel.shape[0])
	tmp_name, tmp_count = np.unique(screen_rel[dum == 1, :2], return_counts = True)
	dum = ~np.in1d(tmp_name, tmp_screen_I)
	tmp_name = tmp_name[dum]
	tmp_count = tmp_count[dum]
	return tmp_name, tmp_count, n_part6mon, n_infPart


def contact_trace_name(n_name_trace, max_contact, p_treat_tr, last_test, unit_per_year, t): 
	'''
	Contact tracing process: 

	Arguments:
	---------
	n_name_trace (numpy array): an 1D array. The number of a partner name being provided from the index case. 
	max_contact (integer): the maximum number of named partners contacted by the public health official
	p_treat_tr (float): the probability that the traced partners are really treated. 
	last_test (numpy array): an 1D array. The last time step individual gets tested. 
	unit_per_year (integer): how many units of time in a year. 
	t (integer): the time step. 

	Return: 
	-------
	num_contact: number of partners contacted by the public health official
	tmp_name: the named partners contacted by the public health officials
	test_name: the partners who were contacted are really tested. 
	'''
	tmp_name = np.where(n_name_trace > 0)[0]
	if tmp_name.shape[0] > max_contact: 
		tmp_count = n_name_trace[tmp_name]
		tmp_sort = np.argsort(-tmp_count)
		tmp_name = tmp_name[tmp_sort]
		tmp_name = tmp_name[:max_contact]

	# number contacted at each time step
	num_contact = tmp_name.shape[0]
	# sample whether the contacted get tested
	dum1 = (np.random.binomial(1, p = p_treat_tr, size = num_contact) == 1)
	dum2 = (t - last_test[tmp_name]) > 2
	test_name = tmp_name[dum1 & dum2]
	return num_contact, tmp_name, test_name, np.sum(dum1) - test_name.shape[0]


def implement_strategy(ID, rel_hist, Npop, time_horizon, unit_per_year, seed_ix, \
	scr_schedule, count_all, strategy = 'null', trend = False, \
	pContact_PN = 0.49, pContact_ept = 0.7, pContact_tr = 0.7, \
	p_treat_PN = 0.71, p_treat_ept = 0.79, p_treat_tr = 0.79): 

	pInf, pCondom, redCondom, acts, pRec, max_contact, max_ept, \
	cMedicine, cInvestigate, cTest, q, discount_rate = get_params(unit_per_year)

	S, I, T, last_test, person_time, n_notification, n_name_trace, n_infection, n_intervention, \
	out_S, out_I, out_T, out_newI, out_ext_seed, out_n_part6mon, out_n_infPart6mon, out_nDeliver, \
	out_nContactTrace, out_nNotified, out_nPartnerTestedBefore, out_nTrueTreat, \
	out_nOvertreat, out_nTest, out_nScreen, out_nTrueTreatIntervention, out_pEfficient, \
	out_CostMedicine, out_CostTracing, out_CostTest = create_tracker_and_outcome_vectors(Npop, time_horizon)

	for t in range(0, time_horizon):  
		## transmission 
		tmp_rel = get_instantaneous_sex_net_of_infected(rel_hist, I, T, t)
		infID, new_infID = trans_dynamics(I, tmp_rel, acts, pInf, pCondom, redCondom)
		tmp_seed = seed_ix[seed_ix[:, 0] == t, 1]
		tmp_seed = np.setdiff1d(tmp_seed, infID)

		## Recovered from treated (Assuming individuals who get treated cannot get infected in a time step)
		treatID = np.where(T == 1)[0]
		T[treatID] = 0
		S[treatID] = 1
		tmp_seed = np.setdiff1d(tmp_seed, treatID)

		out_ext_seed[t] = tmp_seed.shape[0]

		# adding the seeded individuals to new_infID
		new_infID = np.concatenate((new_infID, tmp_seed))

		## screening and testing
		scr_ID = scr_schedule[scr_schedule[:, 0] == t, 1]
		# excluded those who have got tested in the last month (2 steps)
		dum = (t - last_test[scr_ID]) > 2
		scr_ID = scr_ID[dum]
		last_test[scr_ID] = t

		tmp_screen_I = scr_ID[np.in1d(scr_ID, infID)]
		S_ID = np.where(S == 1)[0]
		tmp_screen_S = scr_ID[np.in1d(scr_ID, S_ID)]

		out_nScreen[t] = tmp_screen_I.shape[0] + tmp_screen_S.shape[0]	
		out_nTest[t] = tmp_screen_I.shape[0] + tmp_screen_S.shape[0]
		out_nTrueTreat[t] = tmp_screen_I.shape[0]

		# infected ID who get treated
		if strategy == "tracing": 
			num_contact, trace_name, trace_test_name, tmp_tr = \
				contact_trace_name(n_name_trace, max_contact, p_treat_tr, last_test, unit_per_year, t)
			last_test[trace_test_name] = t
			n_name_trace[trace_name] = 0
			treat_name = trace_test_name[np.in1d(trace_test_name, infID)]
			tmp_screen_I = np.concatenate((tmp_screen_I, treat_name))

			tmp_name, tmp_count, n_part6mon, n_infPart = notify_contact_deliver_sex_part(rel_hist, tmp_screen_I, \
				pContact_tr, unit_per_year, infID, t)
			n_intervention[trace_name] += 1
			n_name_trace[tmp_name] += tmp_count
			out_n_part6mon[t] = n_part6mon
			out_n_infPart6mon[t] = n_infPart

			out_nPartnerTestedBefore[t] = tmp_tr
			out_nTrueTreatIntervention[t] = treat_name.shape[0]
			out_nTest[t] += trace_test_name.shape[0]
			out_nContactTrace[t] = num_contact
			out_nTrueTreat[t] = tmp_screen_I.shape[0]

			if out_nContactTrace[t] == 0:
				out_pEfficient[t] = np.nan
			else:
				out_pEfficient[t] = out_nTrueTreatIntervention[t] / out_nContactTrace[t]

		if strategy == "EPT": 			
			deliver_name, deliver_count, n_part6mon, n_infPart = notify_contact_deliver_sex_part(rel_hist, tmp_screen_I, \
				pContact_ept, unit_per_year, infID, t)
			out_nDeliver[t] = np.sum(deliver_count)
			n_intervention[deliver_name] += 1
			out_n_part6mon[t] = n_part6mon
			out_n_infPart6mon[t] = n_infPart
			dum = (t - last_test[deliver_name]) > 2
			out_nPartnerTestedBefore[t] = np.sum(1 - dum)

			dum = (np.random.binomial(1, p = 1 - (1 - p_treat_ept) ** deliver_count) == 1)
			deliver_name = deliver_name[dum]
			dum = (t - last_test[deliver_name]) > 2

			deliver_name = deliver_name[dum]
			tmp_ept_treat = deliver_name[np.in1d(deliver_name, infID)]
			tmp_screen_I = np.concatenate((tmp_screen_I, tmp_ept_treat))

			out_nTrueTreat[t] = tmp_screen_I.shape[0]
			out_nOvertreat[t] = deliver_name.shape[0] - tmp_ept_treat.shape[0]
			out_nTrueTreatIntervention[t] = tmp_ept_treat.shape[0]
			if out_nDeliver[t] == 0: 
				out_pEfficient[t] = np.nan
			else: 
				out_pEfficient[t] = out_nTrueTreatIntervention[t] / out_nDeliver[t]

		if strategy == "PN": 
			if t >= 1: 
				dum = (t - last_test[notify_name]) > 2
				out_nPartnerTestedBefore[t] = np.sum(1 - dum)
				dum = (np.random.binomial(1, p = 1 - (1 - p_treat_PN) ** (n_notification[notify_name])) == 1)
				notify_test_name = notify_name[dum]
				dum = (t - last_test[notify_test_name]) > 2
				notify_test_name = notify_test_name[dum]
				out_nTest[t] += notify_test_name.shape[0]
				notify_true_treat_name = notify_test_name[np.in1d(notify_test_name, infID)]
				out_nTrueTreatIntervention[t] = notify_true_treat_name.shape[0]
				if out_nNotified[t - 1] == 0: 
					out_pEfficient[t] = np.nan
				else:	
					out_pEfficient[t] = out_nTrueTreatIntervention[t] / out_nNotified[t - 1]
				tmp_screen_I = np.concatenate((tmp_screen_I, notify_true_treat_name))
				n_notification[n_notification > 0] = 0 # Assuming that if partners didn't get tested at the next time step, they won't get tested for the notification. 

			notify_name, tmp_count, n_part6mon, n_infPart = notify_contact_deliver_sex_part(rel_hist, tmp_screen_I, pContact_PN, \
				unit_per_year, infID, t)
			n_notification[notify_name] = tmp_count
			n_intervention[notify_name] += 1
			out_n_part6mon[t] = n_part6mon
			out_n_infPart6mon[t] = n_infPart

			out_nNotified[t] = notify_name.shape[0]
			out_nTrueTreat[t] = tmp_screen_I.shape[0]

		I[tmp_screen_I] = 0
		T[tmp_screen_I] = 1

		## spontaneous recovered ID
		dum = np.random.binomial(1, p = pRec, size = infID.shape[0]) == 1
		new_recID = infID[dum]
		S[new_recID] = 1
		I[new_recID] = 0

		## updated the health state of the newly infected ID
		S[new_infID] = 0
		I[new_infID] = 1
		n_infection[new_infID] += 1

		d_factor = (1 / (1 + discount_rate)) ** (t + 1)
		person_time += I * d_factor

		out_S[t] = np.mean(S)
		out_I[t] = np.mean(I)
		out_T[t] = np.mean(T)
		out_newI[t] = new_infID.shape[0]

		out_CostMedicine[t] = (out_nTrueTreat[t] + out_nOvertreat[t]) * (cMedicine * d_factor)
		out_CostTracing[t] = out_nContactTrace[t] * (cInvestigate * d_factor)
		out_CostTest[t] = out_nTest[t] * (cTest * d_factor)

	if trend == True: 
		return out_I.tolist()
	else: 
		n_yrs = time_horizon / unit_per_year
		sum_all = {}
		sum_all["S"] = out_S[-1]
		sum_all["I"] = out_I[-1]
		sum_all["T"] = out_T[-1]
		sum_all["newI"] = np.nansum(out_newI)
		sum_all["nExtSeed"] = np.mean(out_ext_seed)
		sum_all["n_part6mon"] = np.sum(out_n_part6mon)
		sum_all["n_infPart6mon"] = np.sum(out_n_infPart6mon)
		sum_all["nDeliver"] = np.nansum(out_nDeliver)
		sum_all["nContactTrace"] = np.nansum(out_nContactTrace)
		sum_all["nNotified"] = np.nansum(out_nNotified)
		sum_all["nTrueTreat"] = np.nansum(out_nTrueTreat)
		sum_all["nOvertreat"] = np.nansum(out_nOvertreat)
		sum_all["out_nPartnerTestedBefore"] = np.nansum(out_nPartnerTestedBefore)
		sum_all["nTest"] = np.nansum(out_nTest)
		sum_all["nScreen"] = np.nansum(out_nScreen)
		sum_all["nTrueTreatIntervention"] = np.nansum(out_nTrueTreatIntervention)
		sum_all["pEfficient"] = np.nanmean(out_pEfficient)
		sum_all["pEverInfected"] = np.sum(n_infection > 0) / Npop
		sum_all["averageTimesInfected"] = np.mean(n_infection[n_infection > 0] / n_yrs)
		sum_all["nIntervention"] = np.nansum(n_intervention)
		sum_all["pEverBeenIntervention"] = np.sum(n_intervention > 0) / Npop
		
		if n_intervention[n_intervention > 0].shape[0] > 0: 
			sum_all["avgTimesBeenIntervene"] = np.mean(n_intervention[n_intervention > 0] / n_yrs)
		else: 
			sum_all["avgTimesBeenIntervene"] = 0
		
		sum_all["tot_person_time"] = np.sum(person_time / 2) # convert to months
		sum_all["corr_timesInf_and_degree"] = np.round(np.corrcoef(count_all, n_infection)[0, 1], 4)
		sum_all["corr_PT_and_degree"] = np.round(np.corrcoef(count_all, person_time)[0, 1], 4)
		sum_all["CostMedicine"] = np.nansum(out_CostMedicine)
		sum_all["CostTracing"] = np.nansum(out_CostTracing)
		sum_all["CostTest"] = np.nansum(out_CostTest)
		sum_all["TotalCost"] = sum_all["CostMedicine"] + sum_all["CostTracing"] + sum_all["CostTest"]
		return sum_all


