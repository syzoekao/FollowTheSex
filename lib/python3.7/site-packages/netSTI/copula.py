import numpy as np
from scipy import stats
import netSTI.mydata as data

class DegreeSequence: 
	def __init__(self, Npop): 
		self.Npop = Npop

	def get_degree_power_law(self):
		return np.random.choice(data.PowerLawDD().nPart5yr, p = data.PowerLawDD().plDist5yr, size = self.Npop)
		
	def get_degree_poisson(self, Ndegree):
		return np.random.poisson(Ndegree, size = self.Npop)

	def get_dd_empirical(self, n_yrs): 
		tmp_dd = data.SexBehavior().degree_dist
		tmp_d = data.SexBehavior().degree
		year_d = np.random.choice(tmp_d, p = tmp_dd, size = (self.Npop, n_yrs))
		return np.sum(year_d, axis = 1)


class Copula:
	def __init__(self, graph, el, dd, independent = False):
		if graph == ["random", "community"]: 
			sum_d = 0.5 * dd[el[:, 0]] * (dd[el[:, 0]] > dd[el[:, 1]]) + 0.5 * dd[el[:, 1]] * (dd[el[:, 0]] <= dd[el[:, 1]]) 
		elif graph == "power_law": 
			sum_d = 0.95 * dd[el[:, 1]] * (dd[el[:, 0]] > dd[el[:, 1]]) + 0.05 * dd[el[:, 0]] * (dd[el[:, 0]] <= dd[el[:, 1]]) 
		elif graph == "empirical": 
			sum_d = 0.75 * dd[el[:, 1]] * (dd[el[:, 0]] > dd[el[:, 1]]) + 0.25 * dd[el[:, 0]] * (dd[el[:, 0]] <= dd[el[:, 1]]) 
		else: 
			sum_d = ( dd[el[:, 0]] + dd[el[:, 1]] ) / 2
		sum_d = np.round(sum_d).astype(int)

		corrcoef = 0
		if independent == False: 
			if graph == 'power_law': 
				corrcoef = -0.24
			if graph in ['random', 'community']: 
				corrcoef = -0.13
			if graph == 'empirical': 
				corrcoef = -0.23
		mvnorm = stats.multivariate_normal(mean=[0, 0], 
			cov=[[1., corrcoef], [corrcoef, 1.]])
		x = mvnorm.rvs(el.shape[0])
		norm = stats.norm()
		x_unif = norm.cdf(x)

		# get duration from the joint distribution
		dur_cdf = np.cumsum(data.SexBehavior().dur_dist)
		dum_mat = (np.tile(dur_cdf, (x_unif.shape[0], 1)) <= np.tile(x_unif[:, 1], (dur_cdf.shape[0], 1)).T) * \
			np.tile(np.arange(dur_cdf.shape[0]), (x_unif.shape[0], 1))
		self.dur_samp = np.max(dum_mat, axis = 1) + 1

		# get the degree sequence sample from joint distribution
		nPart, d_ct = np.unique(sum_d, return_counts = True)
		d_pdf = d_ct / np.sum(d_ct)
		d_cdf = np.cumsum(d_pdf)
		dum_mat = (np.tile(d_cdf, (x_unif.shape[0], 1)) <= np.tile(x_unif[:, 0], (d_cdf.shape[0], 1)).T) * \
			np.tile(np.arange(d_cdf.shape[0]), (x_unif.shape[0], 1))
		x1_trans = np.max(dum_mat, axis = 1) + 1
		self.nPart = nPart[x1_trans]
		self.sum_d = sum_d
		self.independent = independent


class CopulaDist(Copula): 
	def __init__(self, graph, el, dd, independent = False): 
		super().__init__(graph, el, dd, independent)

	def get_duration(self):
		if self.independent == False: 
			new_nPart = np.unique(self.nPart)

			lb_vec = np.concatenate((np.zeros(1), new_nPart[:-1]))
			ub_vec = new_nPart
			part_lb = np.zeros(self.nPart.shape[0])
			part_ub = np.zeros(self.nPart.shape[0])

			for i in range(self.nPart.shape[0]):
				x = self.nPart[i]
				tmp = (x - lb_vec) * ((x - lb_vec) > 0)
				part_lb[i] = lb_vec[np.max(np.where(tmp > 0)[0])]	
				if x < np.max(ub_vec): 
					if np.where((x >= ub_vec))[0].shape[0] > 0:
						tmp = np.max(np.where((x >= ub_vec))[0])
					else: 
						tmp = 0
					part_ub[i] = ub_vec[tmp]
				else: 
					part_ub[i] = np.inf

			dur = np.zeros(self.sum_d.shape[0])
			for i in range(dur.shape[0]): 
				x = self.sum_d[i]
				ix = np.where((part_lb <= x) & (part_ub > x))[0]
				dur[i] = np.random.choice(self.dur_samp[ix], 1)

			return dur
		else: 
			return self.dur_samp
