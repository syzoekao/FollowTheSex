import numpy as np
import timeit
import netSTI.netgen as ngen
import netSTI.mydata as data
import netSTI.copula as copula
import netSTI.disease_policy as dp
import pytest


graph = 'empirical'
independent = True

Npop = 5000
years = 5
days = 14 
analysis_window = 2

degree = data.SexBehavior().degree
degree_dist = data.SexBehavior().degree_dist
mean_degree = np.sum(degree * degree_dist)
Ndegree = mean_degree * years
unit_per_year = int(365 / days)
time_horizon = unit_per_year * years
n_cluster = data.Params(unit_per_year).n_cluster

t_begin = (time_horizon - unit_per_year * analysis_window)

ID = np.arange(Npop)
ID_cluster = (np.floor(ID / (Npop/n_cluster)) + 1).astype(int)

cop = copula.CopulaDist(Npop, graph = graph, independent = independent)

if graph in ['random', 'community']: 
	gen_dd = cop.get_degree_poisson(Ndegree)
if graph == 'power_law': 
	gen_dd = cop.get_degree_power_law()
if graph == 'empirical': 
	gen_dd = cop.get_dd_empirical(years)

gen_avg_dur = cop.get_avg_duration()

el = ngen.graph_generator(graph, ID, Npop, Ndegree, time_horizon, years, \
	ID_cluster = ID_cluster, pCluster = 0.99, independent = True)

count_all = ngen.SumNet(el, Npop, time_horizon, t_begin).calc_degree_over_a_window()

pEFoI = (1 / Npop) / 2 * 100

def test_gen_inf_id_from_external():
	inf_independent = False
	if pEFoI > 0: 
		seed_ix = dp.gen_inf_id_from_external(count_all, Npop, pEFoI, ID_cluster, graph, \
			time_horizon, inf_independent = inf_independent)
		count_per_step = np.unique(seed_ix[:, 0], return_counts = True)[1]
		mean_count_per_step = np.sum(count_per_step) / time_horizon
		assert np.abs(mean_count_per_step - Npop * pEFoI) < (np.sqrt(pEFoI * (1 - pEFoI) * Npop) * 4)

		seed_ids = np.unique(seed_ix[:, 1])
		assert all(count_all[seed_ids] > 0)
		if inf_independent == False: 
			assert np.mean(count_all[seed_ids]) > np.mean(count_all)

		if graph == 'community': 
			assert all(ID_cluster[seed_ix[:, 1]] == 1)
	else: 
		seed_ix = dp.gen_inf_id_from_external(count_all, Npop, pEFoI, ID_cluster, graph, \
			time_horizon, inf_independent = inf_independent)
		assert seed_ix.shape[0] == 0

seed_ix = dp.gen_inf_id_from_external(count_all, Npop, pEFoI, ID_cluster, graph, \
	time_horizon, inf_independent = False)


pScr = data.Params(unit_per_year).pScr
def test_make_screening_schedule(): 
	schedule = dp.make_screening_schedule(el, time_horizon, Npop, unit_per_year, pScr)
	sch_yr = np.floor(schedule[:, 0] / unit_per_year)
	
	# check no repeat test ID in the same year. 
	unique_vec = np.zeros(years)
	n_vec = np.zeros(years)
	for yr in range(years): 
		unique_vec[yr] = np.unique(schedule[sch_yr == yr, 1]).shape[0]
		n_vec[yr] = schedule[sch_yr == yr, 1].shape[0]
	assert all(n_vec == unique_vec)

	prop_year = -np.log(1 - pScr) * unit_per_year
	# check the screening rate
	assert np.abs(np.mean(unique_vec) - prop_year * Npop) < (np.sqrt(Npop * prop_year * (1 - prop_year)) * 4)

	assert np.mean(count_all[schedule[:, 1]]) > np.mean(count_all)

scr_schedule = dp.make_screening_schedule(el, time_horizon, Npop, unit_per_year, pScr)

I = np.zeros(Npop)
I[np.random.binomial(1, p = 0.1, size = Npop) == 1] = 1
T = np.zeros(Npop)
T[np.random.binomial(1, p = 0.1, size = Npop) == 1] = 1
T = T * (1 - I)

t = 48
out_rel = dp.get_instantaneous_sex_net_of_infected(el, I, T, t)

def test_get_instantaneous_sex_net_of_infected(): 
	inf_ID = np.where(I == 1)
	test_ID = np.where(T == 1)

	out_ix = np.unique(out_rel[:, :2])
	assert all(~np.in1d(test_ID, out_ix))

	assert all((I[out_rel[:, 0]] + I[out_rel[:, 1]]) == 1)

	assert all((out_rel[:, 2] <= t) & (out_rel[:, 3] >= t))


acts = data.Params().meanActs
pInf = data.Params().pInf
pCondom = data.Params().pCondom
redCondom = data.Params().redCondom

infID, new_infID = dp.trans_dynamics(I, out_rel, acts, pInf, pCondom, redCondom)

def test_trans_dynamics(): 
	assert all(np.in1d(infID, np.where(I == 1)[0]))
	assert all(np.in1d(np.where(I == 1)[0], infID))
	assert all(~np.in1d(new_infID, infID))
	assert all(~np.in1d(new_infID, np.where(T == 1)[0]))


n_name_trace = np.random.choice(np.arange(5), size = Npop)
max_contact = data.Params().max_contact
tmp_screen_I = np.random.choice(infID, size = 10)
p_treat_tr = 0.8
last_test = np.random.choice(np.arange(t), size = Npop)

def test_contact_trace_name(): 
	n_contact, contact_name, test_name = dp.contact_trace_name(n_name_trace, \
		max_contact, p_treat_tr, last_test, unit_per_year, t)
	assert n_contact <= max_contact
	assert n_contact == contact_name.shape[0]
	assert test_name.shape[0] <= n_contact
	assert all(np.in1d(test_name, contact_name))
	assert all((t - last_test[test_name]) >= (unit_per_year / 2))


pContact_PN = 0.49
pContact_ept = 0.7
pContact_tr = 0.7
p_treat_PN = 0.71
p_treat_ept = 0.79
p_treat_tr = 0.79

def test_notify_contact_deliver_sex_part(): 
	pContact = pContact_tr
	tmp_name, tmp_count = dp.notify_contact_deliver_sex_part(el, tmp_screen_I, pContact, unit_per_year, t)
	dum = (el[:, 2] <= t) & ((t - el[:, 3]) <= (unit_per_year / 2))
	tmp_el = el[dum]
	ix1 = tmp_el[np.in1d(tmp_el[:, 0], tmp_screen_I)]
	ix1 = ix1[:, 1]
	ix2 = tmp_el[np.in1d(tmp_el[:, 1], tmp_screen_I)]
	ix2 = ix2[:, 0]
	tmp_ix = np.unique(np.concatenate((ix1, ix2)))

	assert all(np.in1d(tmp_name, tmp_ix))
	assert tmp_ix.shape[0] >= tmp_name.shape[0]


def test_implement_strategy():  
	sum_out = dp.implement_strategy(ID, el, Npop, time_horizon, unit_per_year, seed_ix, \
		scr_schedule, count_all, strategy = 'tracing', trend = True, \
		pContact_PN = 0.49, pContact_ept = 0.7, pContact_tr = 0.7, \
		p_treat_PN = 0.71, p_treat_ept = 0.79, p_treat_tr = 0.79)
	sum_out = dp.implement_strategy(ID, el, Npop, time_horizon, unit_per_year, seed_ix, \
		scr_schedule, count_all, strategy = 'EPT', trend = False, \
		pContact_PN = 0.49, pContact_ept = 0.7, pContact_tr = 0.7, \
		p_treat_PN = 0.71, p_treat_ept = 0.79, p_treat_tr = 0.79)



