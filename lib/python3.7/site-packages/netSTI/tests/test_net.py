import numpy as np
import copy
import timeit
import netSTI.net as net
import netSTI.mydata as data
import netSTI.copula as copula
import pytest

import matplotlib as mpl
from pylab import *
print(mpl.rcParams['backend'])
mpl.use('TkAgg')
import matplotlib.pyplot as plt
plt.get_backend()
import os
os.chdir("/Users/szu-yukao/Documents/Network_structure_and_STI/networkSTI")
cwd = os.getcwd()
print(cwd)


Npop = 5000
years = 10
days = 14 # 14 days; bi-weekly time step
# graph_function = net.random_graph_generator
strategy = "PN" 
meanActs = 27


Ndegree = 4 * years
unit_per_year = int(365 / days)
time_horizon = unit_per_year * years
acts = meanActs / unit_per_year

init_prev, pInf, pCondom, redCondom, pRec, pScr, \
pContact_PN, pContact_ept, pContact_tr, p_treat_PN, p_treat_ept, p_treat_tr, \
max_contact, max_ept, alpha, cMedicine, cInvestigate, cTest, \
n_cluster, q, discount_rate = net.get_params(unit_per_year)


init_inf = int(Npop * init_prev)
ID = np.arange(Npop)
S = np.ones(Npop)
I = np.zeros(Npop)
T = np.zeros(Npop) # this state is only for recording time of treatment

ID_cluster = (np.floor(ID / (Npop/n_cluster)) + 1).astype(int)
init_select = np.where(ID_cluster == 1)[0]
infID = np.sort(np.random.choice(init_select, init_inf, replace = False))
I[infID] = 1
S[infID] = 0


@pytest.mark.skip(reason = "This is not a real test")
def test_random_graph_generator(): 
	n_sim = 500
	cor_vec = np.zeros(n_sim)
	mean_deg = np.zeros(n_sim)
	for z in range(n_sim): 
		print(z)
		g = net.random_graph_generator(ID, Npop, Ndegree, time_horizon, independent = False)
		tmpMatrix = np.zeros((Npop, Npop))
		for i in range(g.shape[0]): 
			x = g[i, 0]
			y = g[i, 1]
			tmpMatrix[x, y] = 1
			tmpMatrix[y, x] = 1
		tmp_degree = np.sum(tmpMatrix, axis = 1)
		mean_deg[z] = np.mean(tmp_degree)

		tmpDur = np.zeros((Npop, Npop))
		tmpDur[:, :] = np.nan
		g_dur = g[:, 3] - g[:, 2]
		for i in range(g.shape[0]): 
			x = g[i, 0]
			y = g[i, 1]
			tmpDur[x, y] = g_dur[i]
			tmpDur[y, x] = g_dur[i]
		tmp_dur = np.nanmean(tmpDur, axis = 1)
		cor_vec[z] = np.round(np.corrcoef(tmp_degree, tmp_dur)[0, 1], 3)

	fig, (ax1, ax2) = plt.subplots(nrows = 1, ncols = 2, figsize=(12,4))
	density, bins = np.histogram(mean_deg, normed = True, density = True, bins = 20)
	unity_density = density / density.sum()
	widths = bins[:-1] - bins[1:]
	ax1.bar(bins[1:], unity_density, width = widths, color = "cornflowerblue")
	ax1.axvline(mean_deg.mean(), color = 'orangered')
	ax1.text(mean_deg.mean(), 0, str(np.round(mean_deg.mean(), 3)))
	ax1.set_xlabel('mean degree')
	ax1.set_ylabel('density')
	ax1.set_title(str(n_sim) + ' samples of random network')

	density, bins = np.histogram(cor_vec, normed = True, density = True, bins = 20)
	unity_density = density / density.sum()
	widths = bins[:-1] - bins[1:]
	ax2.bar(bins[1:], unity_density, width = widths, color = "cornflowerblue")
	ax2.axvline(cor_vec.mean(), color = 'orangered')
	ax2.text(cor_vec.mean(), 0, str(np.round(cor_vec.mean(), 3)))
	ax2.set_xlabel('correlation coefficient\nbetween degree and duration')
	ax2.set_ylabel('density')
	ax2.set_title(str(n_sim) + ' samples of random network')

	plt.tight_layout()
	plt.savefig('results/random dd cc duration (correlated).eps', format='eps', dpi=500)
	plt.clf()
	


@pytest.mark.skip(reason = "This is not a real test")
def test_community_graph_generator(): 
	n_sim = 500
	cor_vec = np.zeros(n_sim)
	p_in_vec = np.zeros(n_sim)
	mean_deg = np.zeros(n_sim)

	same_cluster = np.tile(ID_cluster, (Npop, 1)).T == np.tile(ID_cluster, (Npop, 1))

	for z in range(n_sim): 
		print(z)
		g = net.community_graph_generator(ID, Npop, Ndegree, ID_cluster, time_horizon, \
			pCluster = 0.99, independent = False)
		tmpMatrix = np.zeros((Npop, Npop))
		for i in range(g.shape[0]): 
			x = g[i, 0]
			y = g[i, 1]
			tmpMatrix[x, y] = 1
			tmpMatrix[y, x] = 1
		tmp_degree = np.sum(tmpMatrix, axis = 1)
		mean_deg[z] = np.mean(tmp_degree)

		tmpDur = np.zeros((Npop, Npop))
		tmpDur[:, :] = np.nan
		g_dur = g[:, 3] - g[:, 2]
		for i in range(g.shape[0]): 
			x = g[i, 0]
			y = g[i, 1]
			tmpDur[x, y] = g_dur[i]
			tmpDur[y, x] = g_dur[i]
		tmp_dur = np.nanmean(tmpDur, axis = 1)
		cor_vec[z] = np.round(np.corrcoef(tmp_degree, tmp_dur)[0, 1], 3)

		tmpCluster = tmpMatrix * same_cluster
		tmp_in_degree = np.sum(tmpCluster, axis = 1)
		p_in_vec[z] = np.mean(tmp_in_degree / tmp_degree)

	fig, (ax1, ax2) = plt.subplots(nrows = 1, ncols = 2, figsize=(12,4))
	density, bins = np.histogram(mean_deg, normed = True, density = True, bins = 20)
	unity_density = density / density.sum()
	widths = bins[:-1] - bins[1:]
	ax1.bar(bins[1:], unity_density, width = widths, color = "cornflowerblue")
	ax1.axvline(mean_deg.mean(), color = 'orangered')
	ax1.text(mean_deg.mean(), 0, str(np.round(mean_deg.mean(), 3)))
	ax1.set_xlabel('mean degree')
	ax1.set_ylabel('density')
	ax1.set_title(str(n_sim) + ' samples of community network')

	density, bins = np.histogram(cor_vec, normed = True, density = True, bins = 20)
	unity_density = density / density.sum()
	widths = bins[:-1] - bins[1:]
	ax2.bar(bins[1:], unity_density, width = widths, color = "cornflowerblue")
	ax2.axvline(cor_vec.mean(), color = 'orangered')
	ax2.text(cor_vec.mean(), 0, str(np.round(cor_vec.mean(), 3)))
	ax2.set_xlabel('correlation coefficient\nbetween degree and duration')
	ax2.set_ylabel('density')
	ax2.set_title(str(n_sim) + ' samples of community network')

	plt.tight_layout()
	plt.savefig('results/community dd cc duration (correlated).eps', format='eps', dpi=500)
	plt.clf()



@pytest.mark.skip(reason = "This is not a real test")
def test_power_law_graph_generator(): 
	n_sim = 1000
	cor_vec = np.zeros(n_sim)
	p_in_vec = np.zeros(n_sim)
	mean_deg = np.zeros(n_sim)
	for z in range(n_sim): 
		print(z)
		g = net.community_graph_generator(ID, Npop, Ndegree, ID_cluster, time_horizon, \
			pCluster = 0.99, independent = False)
		tmpMatrix = np.zeros((Npop, Npop))
		for i in range(g.shape[0]): 
			x = g[i, 0]
			y = g[i, 1]
			tmpMatrix[x, y] = 1
			tmpMatrix[y, x] = 1
		tmp_degree = np.sum(tmpMatrix, axis = 1)
		mean_deg[z] = np.mean(tmp_degree)

		tmpDur = np.zeros((Npop, Npop))
		tmpDur[:, :] = np.nan
		g_dur = g[:, 3] - g[:, 2]
		for i in range(g.shape[0]): 
			x = g[i, 0]
			y = g[i, 1]
			tmpDur[x, y] = g_dur[i]
			tmpDur[y, x] = g_dur[i]
		tmp_dur = np.nanmean(tmpDur, axis = 1)
		cor_vec[z] = np.round(np.corrcoef(tmp_degree, tmp_dur)[0, 1], 3)

	fig, (ax1, ax2) = plt.subplots(nrows = 1, ncols = 2, figsize=(12,4))
	density, bins = np.histogram(mean_deg, normed = True, density = True, bins = 20)
	unity_density = density / density.sum()
	widths = bins[:-1] - bins[1:]
	ax1.bar(bins[1:], unity_density, width = widths, color = "cornflowerblue")
	ax1.axvline(mean_deg.mean(), color = 'orangered')
	ax1.text(mean_deg.mean(), 0, str(np.round(mean_deg.mean(), 3)))
	ax1.set_xlabel('mean degree')
	ax1.set_ylabel('density')
	ax1.set_title(str(n_sim) + ' samples of community network')

	density, bins = np.histogram(cor_vec, normed = True, density = True, bins = 20)
	unity_density = density / density.sum()
	widths = bins[:-1] - bins[1:]
	ax2.bar(bins[1:], unity_density, width = widths, color = "cornflowerblue")
	ax2.axvline(cor_vec.mean(), color = 'orangered')
	ax2.text(cor_vec.mean(), 0, str(np.round(cor_vec.mean(), 3)))
	ax2.set_xlabel('correlation coefficient\nbetween degree and duration')
	ax2.set_ylabel('density')
	ax2.set_title(str(n_sim) + ' samples of community network')

	plt.tight_layout()
	plt.savefig('results/community dd cc duration (correlated).eps', format='eps', dpi=500)
	plt.clf()

